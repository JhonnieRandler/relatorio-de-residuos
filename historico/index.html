<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Histórico de Resíduos</title>
    <!-- Metadados para SEO e Descrição da Página -->
    <meta
      name="description"
      content="Histórico detalhado e visualização de resíduos gerados, com gráficos interativos e opções de filtragem."
    />
    <meta name="author" content="Jhon Randler" />
    <meta
      name="keywords"
      content="histórico de resíduos, gestão de resíduos, relatórios, gráficos de resíduos, MTR, dados de resíduos"
    />

    <!-- Open Graph Metadados para Redes Sociais (Facebook, WhatsApp, LinkedIn) -->
    <meta property="og:title" content="Histórico de Resíduos" />
    <meta
      property="og:description"
      content="Histórico detalhado e visualização de resíduos gerados, com gráficos interativos e opções de filtragem."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/historico/"
    />
    <!-- IMPORTANTE: Usar URL absoluta para a imagem para funcionar no WhatsApp e outras plataformas -->
    <meta
      property="og:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta property="og:image:width" content="408" />
    <meta property="og:image:height" content="408" />
    <meta property="og:locale" content="pt_BR" />

    <!-- Twitter Card Metadados -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Histórico de Resíduos" />
    <meta
      name="twitter:description"
      content="Histórico detalhado e visualização de resíduos gerados, com gráficos interactivos e opções de filtragem."
    />
    <meta
      name="twitter:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta name="twitter:creator" content="@JhonnieRandler" />

    <link rel="icon" type="image/png" href="../footer.png" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- Link para o CSS centralizado -->
    <link rel="stylesheet" href="../style.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Preload das imagens para carregamento mais rápido -->
    <link rel="preload" as="image" href="../doubt.png" />
    <link rel="preload" as="image" href="../footer.png" />
    <link rel="preload" as="image" href="../blink.png" />
    <link rel="preload" as="image" href="../like.png" />
    <link rel="preload" as="image" href="../point.png" />
    <link rel="preload" as="image" href="../sure.png" />
    <!-- Preload do áudio -->
    <link rel="preload" as="audio" href="../blink.mp3" />
    <style>
      /* Estilos específicos da página de histórico */
      .buttons {
        margin: 10px 0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap; /* Mantido para que o grupo de filtros e outros botões possam quebrar linha */
      }
      .buttons button {
        margin: 5px; /* Ajuste a margem para melhor espaçamento com flex-wrap */
        white-space: nowrap; /* Adicionado para evitar que o texto quebre em várias linhas nos botões */
      }
      .filter-controls-group {
        display: flex;
        flex-wrap: nowrap; /* ALTERADO: Para manter os itens em uma linha dentro deste grupo */
        gap: 5px;
        align-items: center;
        justify-content: center;
        flex: 0 0 auto;
        min-width: auto;
      }
      .filter-input-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        flex: 1; /* Permite que o input cresça e ocupe o espaço disponível */
        min-width: 180px; /* Mantém um tamanho mínimo para o input */
      }
      .filter-input {
        margin: 0;
        padding: 8px;
        width: 100%;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: 1px solid var(--input-border-color);
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        outline: none;
        transition: background-color 0.3s ease, color 0.3s ease,
          border-color 0.3s ease, box-shadow 0.3s ease;
        padding-right: 30px;
      }
      .clear-filter {
        position: absolute;
        right: 5px;
        padding: 0;
        width: 20px;
        height: 20px;
        background: transparent;
        border: none;
        box-shadow: none;
        cursor: pointer;
        display: none;
        transition: none;
        margin: 0;
      }
      .clear-filter i {
        color: var(--text-color);
        font-size: 14px;
        transition: color 0.3s ease;
      }
      .clear-filter:hover {
        background: transparent;
        border: none;
        box-shadow: none;
      }
      .clear-filter:hover i {
        color: #ff4444;
      }
      #chartContainer {
        width: 100%;
        margin: 20px auto;
        height: 800px;
        padding: 10px;
        box-sizing: border-box;
        display: block;
        border: 1px solid var(--table-border-color);
        border-radius: 8px;
        background-color: var(--table-row-bg);
        min-height: 400px;
        transition: background-color 0.3s ease, border-color 0.3s ease;
      }
      canvas {
        max-width: 100%;
        height: 100%;
        display: block;
        margin: 0 auto;
        width: 100%;
      }
      #modalCancelBtn,
      #bulkEditModalCancelBtn,
      #batchEditModalCancelBtn,
      #filterOptionsModalCancelBtn {
        background-color: #f44336;
      }
      #modalCancelBtn:hover,
      #bulkEditModalCancelBtn:hover,
      #batchEditModalCancelBtn:hover,
      #filterOptionsModalCancelBtn:hover {
        background-color: #d32f2f;
      }

      /* Estilo para o input temporário de edição dentro das células da tabela */
      .editable-table-input {
        width: 100%;
        box-sizing: border-box;
        padding: 4px;
        border: 1px solid var(--input-border-color);
        border-radius: 4px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
      }

      /* Estilo para o input e select do modal de edição em massa */
      .editable-input,
      .editable-select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px;
        border: 1px solid var(--input-border-color);
        border-radius: 8px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        outline: none;
        margin-top: 10px;
      }

      /* Estilo para o checkbox da tabela (linhas individuais) */
      .row-checkbox {
        margin: 0;
        vertical-align: middle;
        width: 18px;
        height: 18px;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        border: 2px solid var(--input-border-color);
        border-radius: 4px;
        background-color: var(--button-bg-color);
        cursor: pointer;
        position: relative;
        display: inline-block;
      }

      .row-checkbox:checked {
        background-color: var(--button-hover-bg-color);
        border-color: var(--button-hover-bg-color);
      }

      .row-checkbox:checked::after {
        content: "\2713";
        color: var(--button-hover-text-color);
        font-size: 14px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      /* Estilo para o checkbox de "selecionar todos" no cabeçalho */
      #selectAllCheckbox {
        margin: 0;
        vertical-align: middle;
        width: 18px;
        height: 18px;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        border: 2px solid var(--input-border-color);
        border-radius: 4px;
        background-color: var(--button-bg-color);
        cursor: pointer;
        position: relative;
        display: inline-block;
      }

      #selectAllCheckbox:checked {
        background-color: var(--button-hover-bg-color);
        border-color: var(--button-hover-bg-color);
      }

      #selectAllCheckbox:checked::after {
        content: "\2713";
        color: var(--button-hover-text-color);
        font-size: 14px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      /* Centraliza o conteúdo das colunas de checkbox e Nº */
      .checkbox-column,
      .number-column {
        text-align: center;
      }

      /* Estilos para os botões de ação em massa */
      .action-button {
        display: none;
      }
      .action-button.active {
        display: inline-block;
      }

      /* Novo estilo para o modal de confirmação para garantir que ele esteja sempre na frente */
      #customConfirmModal,
      #filterOptionsModal {
        z-index: 9999;
      }

      /* Estilos para o novo modal de opções de filtro */
      #filterOptionsModal .modal-content {
        max-width: 450px; /* Ajuste a largura do modal */
        padding: 20px;
        gap: 15px; /* Espaçamento entre os elementos do modal */
      }

      #filterOptionsModal .modal-content h3 {
        margin-top: 0;
        color: var(--text-color);
        text-align: center;
      }

      #filterOptionsModal .filter-group {
        width: 100%;
        border: 1px solid var(--input-border-color);
        border-radius: 8px;
        padding: 10px;
        background-color: var(--card-bg-color);
        display: none; /* Escondido por padrão, mostrado via JS */
        flex-direction: column;
        gap: 10px;
      }

      #filterOptionsModal .filter-group.active {
        /* Para mostrar o grupo ativo */
        display: flex;
      }

      #filterOptionsModal .filter-group label {
        color: var(--text-color);
        font-weight: bold;
        margin-bottom: 5px;
        display: block;
      }

      #filterOptionsModal .filter-group select,
      #filterOptionsModal .filter-group input[type="date"] {
        width: calc(100% - 16px); /* 100% menos padding */
        padding: 8px;
        border: 1px solid var(--input-border-color);
        border-radius: 8px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        box-shadow: 0 2px 4px var(--box-shadow-color);
      }
      #filterOptionsModal .filter-type-select {
        /* Estilo para o seletor de tipo de filtro */
        width: 100%;
        padding: 8px;
        border: 1px solid var(--input-border-color);
        border-radius: 8px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        box-shadow: 0 2px 4px var(--box-shadow-color);
        margin-bottom: 15px;
      }

      #filterOptionsModal .modal-buttons {
        margin-top: 20px;
        justify-content: center;
      }

      /* Media queries específicas da página de histórico */
      @media screen and (max-width: 600px) {
        .filter-controls-group {
          flex-direction: column; /* Força os itens a empilhar em telas menores */
          width: 100%;
          gap: 10px;
          /* flex-wrap: wrap; Mantido para que o grupo possa quebrar linha se for muito grande para a linha */
          min-width: auto;
        }
        .filter-input-wrapper {
          width: 100%;
          flex-basis: auto;
        }
        .buttons #openFilterOptionsBtn, /* Ajuste para o botão de filtro de período */
        .buttons #clearPeriodFilterBtn {
          width: 100%;
          margin-top: 10px;
        }
        #chartContainer {
          height: 500px;
          padding: 5px;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <div class="header-controls">
        <h1>Histórico de Resíduos</h1>
        <button id="themeToggle" class="theme-toggle-button">
          <i class="fas fa-moon"></i>
        </button>
      </div>
      <div class="buttons" id="buttonsContainer">
        <div class="filter-controls-group" id="filterControlsGroup">
          <div class="filter-input-wrapper">
            <input
              type="text"
              class="filter-input"
              id="filterInput"
              placeholder="Filtrar..."
            />
            <button class="clear-filter" id="clearFilter">
              <i class="fas fa-times"></i>
            </button>
          </div>
          <!-- Novo botão para abrir o modal de filtros de período -->
          <button id="openFilterOptionsBtn" class="filter-button">
            <i class="fas fa-calendar-alt"></i> Filtrar Período
          </button>
          <!-- Novo botão para limpar os filtros de período -->
          <button id="clearPeriodFilterBtn" style="display: none">
            <i class="fas fa-times"></i> Limpar Período
          </button>
        </div>
        <button id="clearHistory" style="display: none">
          <i class="fas fa-trash"></i> Apagar Histórico
        </button>
        <button id="downloadChart" style="display: none">
          <i class="fas fa-download"></i> Baixar Gráfico
        </button>
        <button id="copyButton" style="display: none">
          <i class="fas fa-copy"></i> Copiar
        </button>
        <button id="toggleTableVisibility" style="display: none">
          <i class="fas fa-eye-slash"></i> Ocultar Tabela
        </button>
        <button id="toggleEditModeBtn">
          <i class="fas fa-edit"></i> Editar Tabela
        </button>
        <button id="batchEditBtn" class="action-button">
          <i class="fas fa-layer-group"></i> Edição em Lote (<span
            id="batchEditCount"
            >0</span
          >)
        </button>
        <button id="editSelectedBtn" class="action-button">
          <i class="fas fa-edit"></i> Editar Grupo (<span id="selectedCount"
            >0</span
          >)
        </button>
        <button id="deleteSelectedBtn" class="action-button">
          <i class="fas fa-trash"></i> Excluir Selecionados (<span
            id="deleteSelectedCount"
            >0</span
          >)
        </button>
        <button id="backButton" onclick="redirectToMainPage()">
          <i class="fas fa-arrow-left"></i> Voltar
        </button>
      </div>
      <div class="table-container" id="historyTable"></div>
      <div id="chartContainer">
        <canvas id="residuosChart"></canvas>
      </div>
    </main>
    <footer>
      <img id="footerImage" src="../footer.png" alt="Footer Image" />
      <p>
        Este site foi desenvolvido para facilitar a gestão de resíduos gerados,
        oferecendo uma ferramenta prática e acessível. É livre para uso por
        todos!
      </p>
      <!-- Elemento de áudio para o som de blink -->
      <audio id="blinkAudio" preload="auto">
        <source src="../blink.mp3" type="audio/mpeg" />
        Seu navegador não suporta o elemento de áudio.
      </audio>
    </footer>

    <!-- Modal de Confirmação Customizado -->
    <div id="customConfirmModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="confirmModalImage"
          src=""
          alt="Ícone de Confirmação"
          class="modal-image"
        />
        <p id="modalMessage"></p>
        <div class="modal-buttons">
          <button id="modalConfirmBtn">Sim</button>
          <button id="modalCancelBtn">Cancelar</button>
        </div>
      </div>
    </div>

    <!-- Modal de Alerta Customizado -->
    <div id="customAlertModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="alertModalImage"
          src=""
          alt="Ícone de Status"
          class="modal-image"
        />
        <p id="alertMessage"></p>
        <div class="modal-buttons">
          <button id="alertOkBtn">OK</button>
        </div>
      </div>
    </div>

    <!-- Modal de Edição em Massa de Grupo (antigo) -->
    <div id="bulkEditModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="bulkEditModalImage"
          src="../point.png"
          alt="Ícone de Edição em Massa"
          class="modal-image"
        />
        <p id="bulkEditModalMessage">
          Editar Grupo para <span id="bulkEditSelectedCount">0</span> MTR(s):
        </p>
        <input
          type="text"
          id="bulkEditGroupInput"
          class="editable-input"
          placeholder="Nome do Grupo"
        />
        <div class="modal-buttons">
          <button id="bulkEditModalSaveBtn">Salvar</button>
          <button id="bulkEditModalCancelBtn">Cancelar</button>
        </div>
      </div>
    </div>

    <!-- Novo Modal de Edição em Lote (genérico) -->
    <div id="batchEditBatchModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="batchEditModalImage"
          src="../point.png"
          alt="Ícone de Edição em Lote"
          class="modal-image"
        />
        <p id="batchEditModalMessage">
          Editar <span id="batchEditCountModal">0</span> MTR(s) selecionado(s):
        </p>
        <select id="batchEditFieldSelect" class="editable-select">
          <option value="">Selecione o campo para editar</option>
          <option value="razaoSocial1">TRANSPORTADOR</option>
          <option value="razaoSocial2">DESTINADOR</option>
          <option value="tipo">TIPO</option>
          <option value="litros">LITROS</option>
          <option value="toneladas">TONELADAS</option>
          <option value="grupo">GRUPO</option>
        </select>
        <input
          type="text"
          id="batchEditValueInput"
          class="editable-input"
          placeholder="Nova informação"
          style="display: none"
        />
        <div class="modal-buttons">
          <button id="batchEditModalSaveBtn">Salvar</button>
          <button id="batchEditModalCancelBtn">Cancelar</button>
        </div>
      </div>
    </div>

    <!-- NOVO: Modal para Opções de Filtro de Período -->
    <div id="filterOptionsModal" class="modal-overlay">
      <div class="modal-content">
        <h3>Selecione o Tipo de Filtro de Período</h3>

        <select id="filterTypeSelect" class="filter-type-select">
          <option value="">Selecione uma opção</option>
          <option value="month">Filtrar por Mês</option>
          <option value="interval">Filtrar por Intervalo</option>
          <option value="predefined">Períodos Predefinidos</option>
        </select>

        <div id="monthFilterGroup" class="filter-group">
          <label for="modalMonthFilter">Mês:</label>
          <select id="modalMonthFilter" class="editable-select">
            <option value="">Todos os Meses</option>
            <!-- Opções serão preenchidas via JS -->
          </select>
        </div>

        <div id="intervalFilterGroup" class="filter-group">
          <label>Intervalo:</label>
          <input
            type="date"
            id="modalStartDateFilter"
            class="editable-input"
            title="Data Inicial"
          />
          <input
            type="date"
            id="modalEndDateFilter"
            class="editable-input"
            title="Data Final"
          />
        </div>

        <div id="predefinedFilterGroup" class="filter-group">
          <label for="modalPredefinedPeriodFilter">Período:</label>
          <select id="modalPredefinedPeriodFilter" class="editable-select">
            <option value="">Nenhum</option>
            <option value="today">Hoje</option>
            <option value="yesterday">Ontem</option>
            <option value="last_7_days">Últimos 7 dias</option>
            <option value="last_30_days">Últimos 30 dias</option>
            <option value="current_month">Mês Atual</option>
            <option value="last_month">Mês Anterior</option>
            <option value="current_quarter">Trimestre Atual</option>
            <option value="last_quarter">Trimestre Anterior</option>
            <option value="current_year">Ano Atual</option>
            <option value="last_year">Ano Anterior</option>
            <option value="last_6_months">Últimos 6 Meses</option>
            <option value="last_12_months">Últimos 12 Meses</option>
          </select>
        </div>

        <div class="modal-buttons">
          <button id="filterOptionsModalApplyBtn">Aplicar</button>
          <button id="filterOptionsModalCancelBtn">Cancelar</button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <script>
      let sortDirection = {};
      let currentSortColumn = null; // Coluna atualmente ordenada
      let currentSortDirection = "asc"; // Direção atual da ordenação ('asc' ou 'desc')
      let storedData = []; // Declarado aqui, será inicializado em DOMContentLoaded
      let isTableVisible = true; // Estado para a visibilidade da tabela
      let selectedMTRs = new Set(); // Para armazenar os IDs dos MTRs selecionados
      let isEditModeActive = false; // Novo: Estado do modo de edição

      // Estado dos filtros de período
      let currentMonthFilter = "";
      let currentStartDateFilter = "";
      let currentEndDateFilter = "";
      let currentPredefinedPeriodFilter = "";

      // Mapeamento de nomes de colunas para chaves de dados (não usado diretamente para render, mas para referência)
      const columnKeys = {
        DATA: "dataEmissao",
        MTR: "mtrFormatted",
        TRANSPORTADOR: "razaoSocial1",
        DESTINADOR: "razaoSocial2",
        TIPO: "tipo",
        TICKET: "mtrRef",
        LITROS: "litros",
        TONELADAS: "toneladas",
        GRUPO: "grupo",
      };

      // Função para alternar o tema
      function toggleTheme() {
        const htmlElement = document.documentElement;
        const currentTheme = htmlElement.getAttribute("data-theme");
        const themeToggleBtn = document.getElementById("themeToggle");

        if (currentTheme === "dark") {
          htmlElement.removeAttribute("data-theme");
          localStorage.setItem("theme", "light");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
          // Atualiza o gráfico se ele estiver visible, para redesenhar com as novas cores de texto, etc.
          if (
            window.myChart &&
            document.getElementById("chartContainer").style.display !== "none"
          ) {
            updateChart(storedData);
          }
        } else {
          htmlElement.setAttribute("data-theme", "dark");
          localStorage.setItem("theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
          // Atualiza o gráfico se ele estiver visible
          if (
            window.myChart &&
            document.getElementById("chartContainer").style.display !== "none"
          ) {
            updateChart(storedData);
          }
        }
      }

      // Função para aplicar o tema salvo
      function applySavedTheme() {
        const savedTheme = localStorage.getItem("theme");
        const htmlElement = document.documentElement;
        const themeToggleBtn = document.getElementById("themeToggle");

        if (savedTheme === "dark") {
          htmlElement.setAttribute("data-theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        } else {
          htmlElement.removeAttribute("data-theme");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        }
      }

      // Função para redirecionar para a página principal, adaptando-se ao ambiente
      function redirectToMainPage() {
        const isLocal =
          window.location.hostname === "127.0.0.1" ||
          window.location.hostname === "localhost";

        if (isLocal) {
          // Para desenvolvimento local, assume que a página principal está na raiz do servidor
          window.location.href = window.location.origin + "/";
        } else {
          // Para GitHub Pages, usa o caminho absoluto do projeto
          window.location.href =
            "https://jhonnierandler.github.io/relatorio-de-residuos/";
        }
      }

      // Funções para Modais Customizados
      function showConfirmModal(message, onConfirm) {
        const modal = document.getElementById("customConfirmModal");
        const modalMessage = document.getElementById("modalMessage");
        const confirmModalImage = document.getElementById("confirmModalImage");
        const confirmBtn = document.getElementById("modalConfirmBtn");
        const cancelBtn = document.getElementById("modalCancelBtn");

        if (modalMessage) modalMessage.textContent = message;

        if (confirmModalImage) {
          confirmModalImage.src = "../sure.png"; // Caminho relativo da imagem
          confirmModalImage.style.display = "block";
        }

        if (modal) modal.style.display = "flex";

        const handleConfirm = () => {
          onConfirm(true);
          closeConfirmModal();
        };

        const handleCancel = () => {
          onConfirm(false);
          closeConfirmModal();
        };

        const handleKeyDown = (e) => {
          if (e.key === "Enter") {
            e.preventDefault(); // Prevents default Enter behavior (e.g., submitting forms)
            handleConfirm();
          } else if (e.key === "Escape") {
            e.preventDefault(); // Prevents default Esc behavior
            handleCancel();
          }
        };

        const closeConfirmModal = () => {
          if (modal) modal.style.display = "none";
          if (confirmBtn)
            confirmBtn.removeEventListener("click", handleConfirm);
          if (cancelBtn) cancelBtn.removeEventListener("click", handleCancel);
          document.removeEventListener("keydown", handleKeyDown); // Remove keyboard listener
          if (confirmModalImage) confirmModalImage.style.display = "none"; // Oculta a imagem ao fechar
        };

        // Ensure listeners are added only once
        // Clone and replace to remove old listeners robustly
        const newConfirmBtn = confirmBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

        newConfirmBtn.addEventListener("click", handleConfirm);
        newCancelBtn.addEventListener("click", handleCancel);
        document.addEventListener("keydown", handleKeyDown); // Add keyboard listener
      }

      function showAlertModal(message, type) {
        // type: 'success', 'no_data', 'error', 'info', 'exists'
        const modal = document.getElementById("customAlertModal");
        const alertMessage = document.getElementById("alertMessage");
        const alertModalImage = document.getElementById("alertModalImage");
        const okBtn = document.getElementById("alertOkBtn");

        if (alertMessage) alertMessage.textContent = message;
        if (modal) modal.classList.remove("success", "error", "info", "exists"); // Limpa classes anteriores

        let imagePath = "";
        if (type === "success") {
          imagePath = "../like.png";
          if (okBtn) okBtn.style.backgroundColor = "#4CAF50"; // Verde para sucesso
        } else if (type === "no_data" || type === "error") {
          imagePath = "../doubt.png";
          if (okBtn) okBtn.style.backgroundColor = "#f44336"; // Vermelho para erro
        } else if (type === "exists" || type === "info") {
          imagePath = "../point.png"; // Usando point.png para info também
          if (okBtn) okBtn.style.backgroundColor = "#2196F3"; // Azul para info/existe
        }

        if (alertModalImage) {
          alertModalImage.src = imagePath;
          alertModalImage.style.display = "block";
        }

        if (modal) modal.style.display = "flex";

        const handleOk = () => {
          closeAlertModal();
        };

        const handleKeyDown = (e) => {
          if (e.key === "Enter" || e.key === "Escape") {
            e.preventDefault(); // Prevents default behavior (e.g., submitting forms, closing browser search)
            handleOk();
          }
        };

        const closeAlertModal = () => {
          if (modal) modal.style.display = "none";
          if (okBtn) okBtn.removeEventListener("click", handleOk);
          document.removeEventListener("keydown", handleKeyDown); // Remove keyboard listener
          if (alertModalImage) alertModalImage.style.display = "none"; // Oculta a imagem ao fechar
        };

        // Ensure listeners are added only once
        // Clone and replace to remove old listeners robustly
        const newOkBtn = okBtn.cloneNode(true);
        okBtn.parentNode.replaceChild(newOkBtn, okBtn);

        newOkBtn.addEventListener("click", handleOk);
        document.addEventListener("keydown", handleKeyDown); // Add keyboard listener
      }

      // Função para salvar alterações de célula individual
      function saveIndividualCellChange(e) {
        const input = e.target;
        const mtrId = input.dataset.mtrId;
        const dateId = input.dataset.dateId;
        const columnKey = input.dataset.columnKey;
        const newValue = input.value.trim();

        const itemIndex = storedData.findIndex(
          (item) => item.mtrFormatted === mtrId && item.dataEmissao === dateId
        );

        if (itemIndex > -1) {
          const originalValue = storedData[itemIndex][columnKey];
          if (originalValue !== newValue) {
            // Special handling for numeric fields (convert comma to dot for parsing)
            if (columnKey === "litros" || columnKey === "toneladas") {
              const parsedValue = parseFloat(newValue.replace(",", "."));
              if (isNaN(parsedValue)) {
                showAlertModal(
                  `Valor inválido para ${columnKey}. Por favor, insira um número.`,
                  "error"
                );
                // Reverte o valor do input para o original se a validação falhar
                input.value = originalValue;
                return;
              }
              storedData[itemIndex][columnKey] = newValue; // Save as string with comma
            } else {
              storedData[itemIndex][columnKey] = newValue;
            }

            localStorage.setItem("residuosData", JSON.stringify(storedData));
            showAlertModal(
              `Campo '${columnKey}' atualizado para '${newValue}'.`,
              "success"
            );
            // Re-render only if needed (e.g., if sorting or filtering would change due to this edit)
            // For simplicity and consistency, re-render the whole filtered view.
            applyFiltersAndRender(
              document.getElementById("filterInput").value,
              currentMonthFilter, // Usa o estado atual do filtro
              currentStartDateFilter,
              currentEndDateFilter
            );
          }
        }
      }

      // Função para alternar o modo de edição
      function toggleEditMode() {
        isEditModeActive = !isEditModeActive;
        const toggleEditModeBtn = document.getElementById("toggleEditModeBtn");
        if (toggleEditModeBtn) {
          if (isEditModeActive) {
            toggleEditModeBtn.innerHTML =
              '<i class="fas fa-check"></i> Encerrar Edição';
            showAlertModal(
              "Modo de edição ativado. Clique nas células para editar.",
              "info"
            );
          } else {
            toggleEditModeBtn.innerHTML =
              '<i class="fas fa-edit"></i> Editar Tabela';
            showAlertModal(
              "Modo de edição desativado. Alterações salvas.",
              "success"
            );
          }
        }
        // Re-render a tabela para aplicar/remover inputs editáveis
        applyFiltersAndRender(
          document.getElementById("filterInput").value,
          currentMonthFilter,
          currentStartDateFilter,
          currentEndDateFilter
        );
        updateActionButtonsVisibility(); // Ajusta a visibilidade de outros botões
      }

      /**
       * Renders the data in the table.
       * @param {Array<Object>} dataToRender The array of MTR objects to display.
       */
      function renderTable(dataToRender) {
        const historyTable = document.getElementById("historyTable");
        if (dataToRender.length === 0) {
          if (historyTable)
            historyTable.innerHTML =
              "<p>Nenhum dado de histórico disponível.</p>";
          return;
        }

        // Define a ordem e as chaves para as colunas da tabela
        const orderedColumnKeys = [
          { header: "DATA", key: "dataEmissao" },
          { header: "MTR", key: "mtrFormatted" },
          { header: "TRANSPORTADOR", key: "razaoSocial1" },
          { header: "DESTINADOR", key: "razaoSocial2" },
          { header: "TIPO", key: "tipo" },
          { header: "TICKET", key: "mtrRef" },
          { header: "LITROS", key: "litros" },
          { header: "TONELADAS", key: "toneladas" },
          { header: "GRUPO", key: "grupo" },
        ];

        let tableHeadersHtml = `
            <th class="checkbox-column"><input type="checkbox" id="selectAllCheckbox"></th>
            <th class="number-column">Nº</th>
        `;
        orderedColumnKeys.forEach((col) => {
          tableHeadersHtml += `<th data-column="${col.key}">${col.header} <span class="sort-arrow"></span></th>`;
        });

        let tableRows = dataToRender
          .map((data, index) => {
            let cellsHtml = "";
            // Coluna do Checkbox
            cellsHtml += `<td class="checkbox-column"><input type="checkbox" class="row-checkbox" data-mtr-id="${data.mtrFormatted}" data-date-id="${data.dataEmissao}"></td>`;
            // Coluna do Número
            cellsHtml += `<td class="number-column">${index + 1}</td>`;

            orderedColumnKeys.forEach((col) => {
              let cellContent = data[col.key] || "";
              // let tdClasses = ''; // Não é mais necessário para a lógica de underline do grupo aqui

              if (isEditModeActive) {
                // Todas as células relevantes se tornam inputs no modo de edição
                cellHtml = `<td>
                                        <input type="text" class="editable-table-input" value="${cellContent}"
                                               data-column-key="${col.key}"
                                               data-mtr-id="${data.mtrFormatted}"
                                               data-date-id="${data.dataEmissao}">
                                    </td>`;
              } else {
                // Fora do modo de edição, renderiza como texto simples
                cellHtml = `<td>${cellContent}</td>`;
              }
              cellsHtml += cellHtml;
            });

            return `<tr data-mtr-id="${data.mtrFormatted}" data-date-id="${data.dataEmissao}">${cellsHtml}</tr>`;
          })
          .join("");

        if (historyTable) {
          historyTable.innerHTML = `
              <table>
                <thead>
                  <tr>
                    ${tableHeadersHtml}
                  </tr>
                </thead>
                <tbody>
                  ${tableRows}
                </tbody>
              </table>
            `;
        }

        // Adiciona listeners de ordenação aos cabeçalhos (excluindo colunas de checkbox e número)
        const headers = historyTable.querySelectorAll("th[data-column]");
        headers.forEach((header) => {
          header.addEventListener("click", () => {
            const column = header.dataset.column;
            sortTable(column);
          });
        });

        // Atualiza as setas de ordenação
        updateSortArrows();

        // Re-seleciona os checkboxes que estavam marcados antes da renderização
        selectedMTRs.forEach((id) => {
          const [mtrId, dateId] = id.split("_");
          const checkbox = historyTable.querySelector(
            `input.row-checkbox[data-mtr-id="${mtrId}"][data-date-id="${dateId}"]`
          );
          if (checkbox) {
            checkbox.checked = true;
          }
        });

        // Adiciona listeners para os novos inputs (se estiver no modo de edição)
        if (isEditModeActive) {
          historyTable
            .querySelectorAll(".editable-table-input")
            .forEach((input) => {
              input.addEventListener("blur", saveIndividualCellChange);
              input.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                  input.blur(); // Dispara blur para salvar
                }
                if (e.key === "Escape") {
                  // Reverte para o valor original antes do blur
                  const mtrId = input.dataset.mtrId;
                  const dateId = input.dataset.dateId;
                  const columnKey = input.dataset.columnKey;
                  const item = storedData.find(
                    (d) => d.mtrFormatted === mtrId && d.dataEmissao === dateId
                  );
                  if (item) {
                    input.value = item[columnKey] || ""; // Reverte para o valor armazenado
                  }
                  input.blur(); // Dispara blur sem salvar
                }
              });
            });
        }

        updateActionButtonsVisibility(); // Atualiza a visibilidade dos botões de ação após a renderização
      }

      /**
       * Ordena os dados com base na coluna selecionada.
       * @param {string} column A chave de dados para ordenar.
       */
      function sortTable(column) {
        // Determina a direção da ordenação
        if (currentSortColumn === column) {
          currentSortDirection =
            currentSortDirection === "asc" ? "desc" : "asc";
        } else {
          currentSortColumn = column;
          currentSortDirection = "asc";
        }

        const dataToSort = storedData; // Sempre ordena todos os dados armazenados

        dataToSort.sort((a, b) => {
          let valA = a[column];
          let valB = b[column];

          // Tratamento especial para valores numéricos (litros, toneladas, MTR, Ticket)
          if (
            column === "litros" ||
            column === "toneladas" ||
            column === "mtrFormatted" ||
            column === "mtrRef"
          ) {
            // Remove o prefixo "MTR nº: " para MTR, e trata vírgula como separador decimal para números
            if (column === "mtrFormatted")
              valA = String(valA).replace("MTR nº: ", "");
            if (column === "mtrFormatted")
              valB = String(valB).replace("MTR nº: ", "");

            valA = parseFloat(String(valA).replace(",", ".") || 0);
            valB = parseFloat(String(valB).replace(",", ".") || 0);

            if (isNaN(valA)) valA = -Infinity; // Trata "Não encontrada" ou "N/A" como o menor valor
            if (isNaN(valB)) valB = -Infinity;

            return currentSortDirection === "asc" ? valA - valB : valB - valA;
          }

          // Tratamento especial para data (DD/MM/YYYY)
          if (column === "dataEmissao") {
            // Converte DD/MM/YYYY para ISO నేపథ్యంలో-MM-DD para comparação correta
            const dateA = valA.split("/").reverse().join("-");
            const dateB = valB.split("/").reverse().join("-");
            if (dateA < dateB) return currentSortDirection === "asc" ? -1 : 1;
            if (dateA > dateB) return currentSortDirection === "asc" ? 1 : -1;
            return 0;
          }

          // Comparação de string padrão (incluindo o novo campo 'grupo')
          if (typeof valA === "string" && typeof valB === "string") {
            valA = normalizeString(valA); // Normaliza para ordenação sem acentos
            valB = normalizeString(valB); // Normaliza para ordenação sem acentos
            if (valA < valB) return currentSortDirection === "asc" ? -1 : 1;
            if (valA > valB) return currentSortDirection === "asc" ? 1 : -1;
          }
          return 0;
        });

        // Re-renderiza a tabela com os dados ordenados e atualiza o gráfico (se necessário com base nos filtros atuais)
        const filterInput = document.getElementById("filterInput");
        applyFiltersAndRender(
          filterInput.value,
          currentMonthFilter,
          currentStartDateFilter,
          currentEndDateFilter
        );
      }

      /**
       * Atualiza as setas de ordenação nos cabeçalhos da tabela.
       */
      function updateSortArrows() {
        const headers = document.querySelectorAll("#historyTable th");
        headers.forEach((header) => {
          let arrowSpan = header.querySelector(".sort-arrow");
          if (!arrowSpan) {
            // Cria se não existir
            arrowSpan = document.createElement("span");
            arrowSpan.classList.add("sort-arrow");
            header.appendChild(arrowSpan);
          }
          arrowSpan.textContent = ""; // Limpa a seta anterior
          // Adiciona a seta apenas às colunas ordenáveis (aquelas com data-column)
          if (header.dataset.column === currentSortColumn) {
            arrowSpan.textContent =
              currentSortDirection === "asc" ? " ↑" : " ↓";
          }
        });
      }

      document
        .getElementById("clearHistory")
        .addEventListener("click", clearHistory);

      function clearHistory() {
        showConfirmModal(
          "Tem certeza que deseja apagar todo o histórico? Esta ação não pode ser desfeita.",
          (confirmed) => {
            if (confirmed) {
              localStorage.removeItem("residuosData");
              // Reatribui storedData para refletir o armazenamento local limpo
              storedData = JSON.parse(
                localStorage.getItem("residuosData") || "[]"
              );
              selectedMTRs.clear(); // Limpa seleções
              renderTable([]);
              updateChart([]);
              toggleButtons(); // Reajusta botões gerais
              toggleTableVisibility(false); // Esconde a tabela ao limpar o histórico
              const toggleTableBtn = document.getElementById(
                "toggleTableVisibility"
              );
              if (toggleTableBtn) {
                toggleTableBtn.innerHTML =
                  '<i class="fas fa-eye"></i> Exibir Tabela';
                isTableVisible = false; // Atualiza o estado
              }
              updateActionButtonsVisibility(); // Reajusta botões de ação em massa
            }
          }
        );
      }

      function updateChart(data) {
        const dataToUse = data.length > 0 ? data : storedData;
        const chartContainer = document.getElementById("chartContainer");

        if (dataToUse.length === 0) {
          if (chartContainer) chartContainer.style.display = "none";
          return;
        } else {
          if (chartContainer) chartContainer.style.display = "block";
        }

        const tipos = [
          ...new Set(
            dataToUse
              .map((item) => item.tipo)
              .filter((tipo) => tipo !== "Não encontrado")
          ),
        ];
        const litrosPorTipo = tipos.map((tipo) => {
          const sum = dataToUse
            .filter((item) => item.tipo === tipo && item.litros)
            .reduce(
              (sum, item) =>
                sum + (parseFloat(item.litros.replace(",", ".")) || 0),
              0
            );
          return sum.toFixed(2);
        });
        const toneladasPorTipo = tipos.map((tipo) => {
          const sum = dataToUse
            .filter((item) => item.tipo === tipo && item.toneladas)
            .reduce(
              (sum, item) =>
                sum + (parseFloat(item.toneladas.replace(",", ".")) || 0),
              0
            );
          return sum.toFixed(2);
        });

        const maxValue = Math.max(
          ...litrosPorTipo.map((v) => parseFloat(v)),
          ...toneladasPorTipo.map((v) => parseFloat(v))
        );
        // Aumenta o multiplicador para dar mais espaço acima das barras.
        const yMax = maxValue ? maxValue * 1.35 : 10; // Alterado de 1.25 para 1.35 para mais espaço

        const canvas = document.getElementById("residuosChart");
        const ctx = canvas.getContext("2d");
        // Atualizar tamanho do canvas dinamicamente
        if (chartContainer) {
          // Garante que chartContainer exista
          canvas.width = chartContainer.clientWidth - 20; // Subtrair padding e margens
          canvas.height = chartContainer.clientHeight - 20;
        }

        // Já define o fundo do canvas como branco.
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Obter as cores do tema atual para o texto e as grades do gráfico
        const computedStyle = getComputedStyle(document.documentElement);
        const textColor = computedStyle.getPropertyValue("--text-color").trim();
        const gridColor = computedStyle
          .getPropertyValue("--table-border-color")
          .trim();

        if (window.myChart) window.myChart.destroy();
        window.myChart = new Chart(ctx, {
          type: "bar",
          plugins: [ChartDataLabels],
          data: {
            labels: tipos,
            datasets: [
              {
                label: "Litros",
                data: litrosPorTipo,
                backgroundColor: "rgba(75, 192, 192, 0.6)",
                borderColor: "rgba(75, 192, 192, 1)",
                borderWidth: 1,
                stack: "Stack 0",
              },
              {
                label: "Toneladas",
                data: toneladasPorTipo,
                backgroundColor: "rgba(255, 99, 132, 0.6)",
                borderColor: "rgba(255, 99, 132, 1)",
                borderWidth: 1,
                stack: "Stack 0",
              },
            ],
          },
          options: {
            maintainAspectRatio: false,
            responsive: true,
            // Adiciona padding ao layout do gráfico
            layout: {
              padding: {
                top: 40, // Aumentado para dar mais espaço no topo
                right: 20, // Adiciona 20px de padding à direita
                bottom: 0,
                left: 0,
              },
            },
            scales: {
              x: {
                ticks: {
                  color: textColor, // Cor dos rótulos do eixo X
                },
                grid: {
                  color: gridColor, // Cor das linhas de grade do eixo X
                },
              },
              y: {
                beginAtZero: true,
                max: yMax,
                stacked: true,
                grid: {
                  display: false,
                  color: gridColor, // Cor das linhas de grade do eixo Y
                },
                ticks: {
                  display: false,
                  color: textColor, // Cor dos rótulos do eixo Y
                },
              },
            },
            plugins: {
              legend: {
                position: "bottom",
                labels: {
                  color: textColor, // Cor do texto da legenda
                },
              },
              datalabels: {
                anchor: "end",
                align: "top",
                formatter: (value, ctx) => {
                  if (parseFloat(value) > 0) {
                    return ctx.dataset.label === "Litros" ||
                      ctx.dataset.label === "Toneladas"
                      ? value
                      : "";
                  }
                  return "";
                },
                color: textColor, // Cor dos rótulos de dados
                font: { weight: "bold" },
                offset: 5,
              },
            },
          },
        });
        // Forçar resize após renderização
        window.myChart.resize();
      }

      // Função de throttling
      function throttle(func, delay) {
        let timeoutId;
        return function (...args) {
          if (!timeoutId) {
            timeoutId = setTimeout(() => {
              func.apply(this, args);
              timeoutId = null;
            }, delay);
          }
        };
      }

      // Listener para redimensionamento da janela, agora com throttling
      window.addEventListener(
        "resize",
        throttle(() => {
          if (
            window.myChart &&
            document.getElementById("chartContainer").style.display !== "none"
          ) {
            updateChart(
              JSON.parse(localStorage.getItem("residuosData") || "[]")
            );
          }
        }, 200)
      ); // Atraso de 200ms

      // Função para copiar texto para a área de transferência
      function copyToClipboard(text) {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        // Torna o textarea invisível
        textarea.style.position = "fixed";
        textarea.style.top = "0";
        textarea.style.left = "0";
        textarea.style.width = "1em";
        textarea.style.height = "1em";
        textarea.style.border = "none";
        textarea.style.outline = "none";
        textarea.style.boxShadow = "none";
        textarea.style.background = "transparent";
        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();
        try {
          const successful = document.execCommand("copy");
          return successful;
        } catch (err) {
          console.error("Erro ao copiar:", err);
          return false;
        } finally {
          document.body.removeChild(textarea);
        }
      }

      document.getElementById("copyButton").addEventListener("click", () => {
        const table = document.querySelector("#historyTable table");
        if (!table) {
          showAlertModal("Nenhum dado para copiar.", "no_data");
          return;
        }

        const tableRows = table.querySelectorAll("tbody tr");
        if (tableRows.length === 0) {
          showAlertModal("Nenhum dado para copiar.", "no_data");
          return;
        }

        const fullTextToCopy = Array.from(tableRows)
          .map((row) => {
            const cells = Array.from(row.cells);
            // Copia o texto de todas as células, exceto as duas primeiras (checkbox e número de ordem)
            // e a última (coluna GRUPO).
            return cells
              .slice(2, -1)
              .map((cell) => cell.textContent.trim())
              .join("\t");
          })
          .join("\n");

        const finalCopyText = fullTextToCopy;

        if (copyToClipboard(finalCopyText)) {
          showAlertModal(
            "Dados copiados para a área de transferência!",
            "success"
          );
        } else {
          showAlertModal("Erro ao copiar os dados.", "error");
        }
      });

      // Função para limpar todos os filtros de período e texto
      document
        .getElementById("clearPeriodFilterBtn")
        .addEventListener("click", () => {
          currentMonthFilter = "";
          currentStartDateFilter = "";
          currentEndDateFilter = "";
          currentPredefinedPeriodFilter = "";
          document.getElementById("filterInput").value = ""; // Limpa o filtro de texto
          updateFilterButtonText(); // Restaura o texto do botão "Filtrar Período"
          document.getElementById("clearPeriodFilterBtn").style.display =
            "none"; // Esconde o botão de limpar
          document.getElementById("clearFilter").style.display = "none"; // Esconde o limpar do filtro de texto
          applyFiltersAndRender("", "", "", ""); // Re-renderiza com todos os filtros vazios
        });

      // Nova função para ocultar/exibir a tabela
      function toggleTableVisibility(forceState = null) {
        const tableContainer = document.getElementById("historyTable");
        const toggleTableBtn = document.getElementById("toggleTableVisibility");

        if (!tableContainer || !toggleTableBtn) return;

        if (forceState !== null) {
          isTableVisible = forceState;
        } else {
          isTableVisible = !isTableVisible;
        }

        if (isTableVisible) {
          tableContainer.style.opacity = "1";
          tableContainer.style.height = "auto"; // Reverte para altura automática
          tableContainer.style.overflow = "auto"; // Reverte para overflow automático
          toggleTableBtn.innerHTML =
            '<i class="fas fa-eye-slash"></i> Ocultar Tabela';
        } else {
          tableContainer.style.opacity = "0";
          tableContainer.style.height = "0"; // Define altura para 0
          tableContainer.style.overflow = "hidden"; // Oculta o overflow
          toggleTableBtn.innerHTML = '<i class="fas fa-eye"></i> Exibir Tabela';
        }
      }

      // Adiciona listener para o botão de toggle da tabela
      document
        .getElementById("toggleTableVisibility")
        .addEventListener("click", () => toggleTableVisibility());

      // Função para trocar a imagem do rodapé e reproduzir áudio
      function swapFooterImage(imgElement) {
        const originalSrc = imgElement.src;
        // Adapta o caminho da imagem de blink para a página de histórico
        const blinkSrc = originalSrc.includes("footer.png")
          ? originalSrc.replace("footer.png", "blink.png")
          : "../blink.png";
        const audio = document.getElementById("blinkAudio");

        imgElement.src = blinkSrc;
        if (audio) {
          audio.currentTime = 0; // Reinicia o áudio se já estiver tocando
          audio
            .play()
            .catch((e) => console.error("Erro ao reproduzir áudio:", e));
        }
        setTimeout(() => {
          imgElement.src = originalSrc;
        }, 400); // 400 milissegundos
      }

      // Função para remover acentos e converter para minúsculas
      function normalizeString(str) {
        return String(str) // Garante que str seja string antes de normalizar
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toLowerCase();
      }

      /**
       * Aplica filtros e renderiza a tabela e o gráfico.
       * @param {string} filterText O texto para filtrar.
       * @param {string} selectedMonthYear O mês/ano selecionado no formato "MM/YYYY".
       * @param {string} startDateString A data de início selecionada no formato "YYYY-MM-DD".
       * @param {string} endDateString A data de fim selecionada no formato "YYYY-MM-DD".
       */
      function applyFiltersAndRender(
        filterText,
        selectedMonthYear,
        startDateString,
        endDateString
      ) {
        let filteredData = storedData;

        // 1. Aplicar filtro de texto sem considerar acentos
        if (filterText) {
          const normalizedFilter = normalizeString(filterText);
          filteredData = filteredData.filter((item) =>
            Object.values(item).some((value) =>
              normalizeString(String(value)).includes(normalizedFilter)
            )
          );
        }

        // 2. Aplicar filtro de Mês/Ano
        if (selectedMonthYear) {
          filteredData = filteredData.filter((item) => {
            const parts = item.dataEmissao.split("/");
            return (
              parts.length === 3 &&
              `${parts[1]}/${parts[2]}` === selectedMonthYear
            );
          });
        }

        // 3. Aplicar filtro de Intervalo de Datas
        if (startDateString && endDateString) {
          const startDate = new Date(startDateString + "T00:00:00"); // Adiciona T00:00:00 para evitar problemas de fuso horário
          const endDate = new Date(endDateString + "T23:59:59"); // Adiciona T23:59:59 para incluir o dia inteiro

          filteredData = filteredData.filter((item) => {
            const itemDateParts = item.dataEmissao.split("/");
            if (itemDateParts.length === 3) {
              const itemDate = new Date(
                `${itemDateParts[2]}-${itemDateParts[1]}-${itemDateParts[0]}T12:00:00`
              ); // Meio-dia para evitar problemas de fuso horário
              return itemDate >= startDate && itemDate <= endDate;
            }
            return false;
          });
        }

        renderTable(filteredData);
        updateChart(filteredData);
        updateFilterButtonText(); // Atualiza o texto do botão de filtro principal
        updateClearPeriodFilterButtonVisibility(); // Atualiza a visibilidade do botão de limpar período
      }

      /**
       * Calcula as datas de início e fim para períodos predefinidos.
       * @param {string} period O nome do período predefinido (e.g., 'last_7_days', 'current_month').
       * @returns {{startDate: string|null, endDate: string|null}} Objeto contendo as datas formatadas como "YYYY-MM-DD".
       */
      function getDatesForPeriod(period) {
        const today = new Date();
        let startDate = null;
        let endDate = new Date(today); // Clone today for endDate

        // Helper para formatar a data como నేపథ్యంలో-MM-DD
        const formatDate = (date) => date.toISOString().slice(0, 10);

        switch (period) {
          case "today":
            startDate = new Date(
              today.getFullYear(),
              today.getMonth(),
              today.getDate()
            );
            break;
          case "yesterday":
            startDate = new Date(today);
            startDate.setDate(today.getDate() - 1);
            endDate = new Date(startDate); // Ontem também termina no mesmo dia
            break;
          case "last_7_days":
            startDate = new Date(today);
            startDate.setDate(today.getDate() - 6); // Inclui o dia de hoje
            break;
          case "last_30_days":
            startDate = new Date(today);
            startDate.setDate(today.getDate() - 29); // Inclui o dia de hoje
            break;
          case "current_month":
            startDate = new Date(today.getFullYear(), today.getMonth(), 1);
            endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0); // Último dia do mês
            break;
          case "last_month":
            startDate = new Date(today.getFullYear(), today.getMonth() - 1, 1);
            endDate = new Date(today.getFullYear(), today.getMonth(), 0); // Último dia do mês anterior
            break;
          case "current_quarter":
            const currentMonth = today.getMonth();
            const currentQuarterStartMonth = Math.floor(currentMonth / 3) * 3;
            startDate = new Date(
              today.getFullYear(),
              currentQuarterStartMonth,
              1
            );
            endDate = new Date(
              today.getFullYear(),
              currentQuarterStartMonth + 3,
              0
            ); // Último dia do trimestre atual
            break;
          case "last_quarter":
            const lastQuarterStartMonth =
              Math.floor(today.getMonth() / 3) * 3 - 3;
            startDate = new Date(today.getFullYear(), lastQuarterStartMonth, 1);
            endDate = new Date(
              today.getFullYear(),
              lastQuarterStartMonth + 3,
              0
            ); // Último dia do trimestre anterior
            break;
          case "current_year":
            startDate = new Date(today.getFullYear(), 0, 1);
            endDate = new Date(today.getFullYear(), 11, 31);
            break;
          case "last_year":
            startDate = new Date(today.getFullYear() - 1, 0, 1);
            endDate = new Date(today.getFullYear() - 1, 11, 31);
            break;
          case "last_6_months":
            startDate = new Date(today.getFullYear(), today.getMonth() - 5, 1); // 6 meses atrás, começando no dia 1
            endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0); // Último dia do mês atual
            break;
          case "last_12_months":
            startDate = new Date(today.getFullYear(), today.getMonth() - 11, 1); // 12 meses atrás, começando no dia 1
            endDate = new Date(today.getFullYear(), today.getMonth() + 1, 0); // Último dia do mês atual
            break;
          default:
            // Nenhuma seleção de período ou período inválido
            return { startDate: null, endDate: null };
        }
        return {
          startDate: formatDate(startDate),
          endDate: formatDate(endDate),
        };
      }

      // Atualiza o texto do botão principal de filtro de período
      function updateFilterButtonText() {
        const openFilterOptionsBtn = document.getElementById(
          "openFilterOptionsBtn"
        );
        if (!openFilterOptionsBtn) return;

        let buttonText = '<i class="fas fa-calendar-alt"></i> Filtrar Período';
        let isFilterActive = false;

        if (currentMonthFilter) {
          const [monthNum, yearNum] = currentMonthFilter.split("/").map(Number);
          const monthName = new Date(yearNum, monthNum - 1).toLocaleString(
            "pt-BR",
            { month: "long" }
          );
          buttonText = `<i class="fas fa-calendar-alt"></i> Mês: ${
            monthName.charAt(0).toUpperCase() + monthName.slice(1)
          }/${yearNum}`;
          isFilterActive = true;
        } else if (currentStartDateFilter && currentEndDateFilter) {
          const start = new Date(currentStartDateFilter);
          const end = new Date(currentEndDateFilter);
          const startDateFormatted = `${String(start.getDate()).padStart(
            2,
            "0"
          )}/${String(start.getMonth() + 1).padStart(
            2,
            "0"
          )}/${start.getFullYear()}`;
          const endDateFormatted = `${String(end.getDate()).padStart(
            2,
            "0"
          )}/${String(end.getMonth() + 1).padStart(
            2,
            "0"
          )}/${end.getFullYear()}`;
          buttonText = `<i class="fas fa-calendar-alt"></i> Intervalo: ${startDateFormatted} - ${endDateFormatted}`;
          isFilterActive = true;
        } else if (currentPredefinedPeriodFilter) {
          const periodNames = {
            today: "Hoje",
            yesterday: "Ontem",
            last_7_days: "Últimos 7 dias",
            last_30_days: "Últimos 30 dias",
            current_month: "Mês Atual",
            last_month: "Mês Anterior",
            current_quarter: "Trimestre Atual",
            last_quarter: "Trimestre Anterior",
            current_year: "Ano Atual",
            last_year: "Ano Anterior",
            last_6_months: "Últimos 6 Meses",
            last_12_months: "Últimos 12 Meses",
          };
          buttonText = `<i class="fas fa-calendar-alt"></i> Período: ${
            periodNames[currentPredefinedPeriodFilter] || "Personalizado"
          }`;
          isFilterActive = true;
        }

        openFilterOptionsBtn.innerHTML = buttonText;
        document.getElementById("clearPeriodFilterBtn").style.display =
          isFilterActive ? "inline-block" : "none";
      }

      // Atualiza a visibilidade do botão "Limpar Período"
      function updateClearPeriodFilterButtonVisibility() {
        const clearPeriodFilterBtn = document.getElementById(
          "clearPeriodFilterBtn"
        );
        if (clearPeriodFilterBtn) {
          const isAnyPeriodFilterActive =
            currentMonthFilter ||
            currentStartDateFilter ||
            currentEndDateFilter ||
            currentPredefinedPeriodFilter;
          clearPeriodFilterBtn.style.display = isAnyPeriodFilterActive
            ? "inline-block"
            : "none";
        }
      }

      // Função para alternar a visibilidade dos botões gerais (fora do modo de edição)
      // Esta função é chamada por updateActionButtonsVisibility.
      function toggleButtons() {
        const buttonsContainer = document.getElementById("buttonsContainer");
        const backButton = document.getElementById("backButton");

        if (buttonsContainer) {
          buttonsContainer.style.justifyContent = "center"; // Sempre centralizado
        }
        // backButton display e margin são controlados por updateActionButtonsVisibility
      }

      // Função que controla a visibilidade de todos os botões de ação e filtros
      function updateActionButtonsVisibility() {
        const editSelectedBtn = document.getElementById("editSelectedBtn");
        const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
        const selectedCountSpan = document.getElementById("selectedCount");
        const deleteSelectedCountSpan = document.getElementById(
          "deleteSelectedCount"
        );
        const toggleEditModeBtn = document.getElementById("toggleEditModeBtn");
        const batchEditBtn = document.getElementById("batchEditBtn"); // Novo botão de edição em lote

        // Sempre atualiza as contagens de itens selecionados
        if (selectedCountSpan)
          selectedCountSpan.textContent = selectedMTRs.size;
        if (deleteSelectedCountSpan)
          deleteSelectedCountSpan.textContent = selectedMTRs.size;
        if (batchEditBtn) {
          // Atualiza a contagem no botão de edição em lote
          const batchEditCountSpan =
            batchEditBtn.querySelector("#batchEditCount");
          if (batchEditCountSpan)
            batchEditCountSpan.textContent = selectedMTRs.size;
        }

        const hasStoredData = storedData.length > 0;

        // Visibilidade do botão "Editar Tabela"
        if (toggleEditModeBtn) {
          if (hasStoredData && selectedMTRs.size === 0) {
            // Mostra se há dados e nenhum item está selecionado
            toggleEditModeBtn.style.display = "inline-block";
          } else if (isEditModeActive) {
            // Mantém visível se já estiver no modo de edição (para o botão "Encerrar Edição")
            toggleEditModeBtn.style.display = "inline-block";
          } else {
            toggleEditModeBtn.style.display = "none";
          }
        }

        // Visibilidade dos botões de ação em massa (Editar Grupo/Excluir Selecionados)
        // Visíveis apenas se houver itens selecionados E não estiver no modo de edição global
        if (selectedMTRs.size > 0 && !isEditModeActive) {
          if (editSelectedBtn) editSelectedBtn.classList.add("active");
          if (deleteSelectedBtn) deleteSelectedBtn.classList.add("active");
        } else {
          if (editSelectedBtn) editSelectedBtn.classList.remove("active");
          if (deleteSelectedBtn) deleteSelectedBtn.classList.remove("active");
        }

        // Visibilidade do botão "Edição em Lote"
        // Visível apenas se estiver no modo de edição global E houver itens selecionados
        if (batchEditBtn) {
          if (isEditModeActive && selectedMTRs.size > 0) {
            batchEditBtn.classList.add("active");
          } else {
            batchEditBtn.classList.remove("active");
          }
        }

        // Visibilidade dos botões e controles gerais (exceto o botão "Editar Tabela" e os de ação em massa)
        const clearButton = document.getElementById("clearHistory");
        const downloadButton = document.getElementById("downloadChart");
        const copyButton = document.getElementById("copyButton");
        const filterInputWrapper = document.querySelector(
          ".filter-input-wrapper"
        ); // Campo de filtro de texto
        const chartContainer = document.getElementById("chartContainer");
        const openFilterOptionsBtn = document.getElementById(
          "openFilterOptionsBtn"
        );
        const clearPeriodFilterBtn = document.getElementById(
          "clearPeriodFilterBtn"
        );

        if (isEditModeActive) {
          // Esconde a maioria dos botões e controles quando no modo de edição
          if (clearButton) clearButton.style.display = "none";
          if (downloadButton) downloadButton.style.display = "none";
          if (copyButton) copyButton.style.display = "none";
          if (filterInputWrapper) filterInputWrapper.style.display = "none"; // Esconde o campo de filtro de texto
          if (openFilterOptionsBtn) openFilterOptionsBtn.style.display = "none"; // Esconde o botão de abrir filtro de período
          if (clearPeriodFilterBtn) clearPeriodFilterBtn.style.display = "none"; // Esconde o botão de limpar período
          if (chartContainer) chartContainer.style.display = "none";
          if (document.getElementById("clearFilter"))
            document.getElementById("clearFilter").style.display = "none"; // Clear filter do input de texto
          if (document.getElementById("toggleTableVisibility"))
            document.getElementById("toggleTableVisibility").style.display =
              "none";
          // O botão de "Voltar" e o "Theme Toggle" permanecem visíveis
        } else {
          // Quando não está no modo de edição, restaura a visibilidade baseada na existência de dados
          if (hasStoredData) {
            if (clearButton) clearButton.style.display = "inline-block";
            if (downloadButton) downloadButton.style.display = "inline-block";
            if (copyButton) copyButton.style.display = "inline-block";
            if (filterInputWrapper) filterInputWrapper.style.display = "flex"; // Exibe o campo de filtro de texto
            if (openFilterOptionsBtn)
              openFilterOptionsBtn.style.display = "inline-block"; // Exibe o botão de abrir filtro de período
            updateClearPeriodFilterButtonVisibility(); // Reavalia visibilidade do botão de limpar período
            if (chartContainer) chartContainer.style.display = "block";
            if (document.getElementById("clearFilter"))
              document.getElementById("clearFilter").style.display =
                document.getElementById("filterInput").value
                  ? "inline-block"
                  : "none";
            if (document.getElementById("toggleTableVisibility"))
              document.getElementById("toggleTableVisibility").style.display =
                "inline-block";
          } else {
            // Se não há dados, esconde todos, exceto o botão de voltar e o toggle de tema
            if (clearButton) clearButton.style.display = "none";
            if (downloadButton) downloadButton.style.display = "none";
            if (copyButton) copyButton.style.display = "none";
            if (filterInputWrapper) filterInputWrapper.style.display = "none";
            if (openFilterOptionsBtn)
              openFilterOptionsBtn.style.display = "none";
            if (clearPeriodFilterBtn)
              clearPeriodFilterBtn.style.display = "none";
            if (chartContainer) chartContainer.style.display = "none";
            if (document.getElementById("clearFilter"))
              document.getElementById("clearFilter").style.display = "none";
            if (document.getElementById("toggleTableVisibility"))
              document.getElementById("toggleTableVisibility").style.display =
                "none";
          }
        }
        // Controla a margem do botão de "Voltar"
        const backButton = document.getElementById("backButton");
        if (backButton) {
          backButton.style.margin =
            hasStoredData && !(isEditModeActive && selectedMTRs.size > 0)
              ? "5px"
              : "0 auto";
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        applySavedTheme(); // Aplica o tema salvo ao carregar a página

        const themeToggleBtn = document.getElementById("themeToggle");
        if (themeToggleBtn) {
          themeToggleBtn.addEventListener("click", toggleTheme);
        }

        // Inicializa storedData e as variáveis globais aqui
        // Garante que cada item tenha a propriedade 'grupo'
        storedData = JSON.parse(
          localStorage.getItem("residuosData") || "[]"
        ).map((item) => {
          if (item.grupo === undefined) {
            item.grupo = ""; // Inicializa nova propriedade 'grupo'
          }
          return item;
        });

        // Referências para os elementos do novo modal de filtros
        const filterOptionsModal =
          document.getElementById("filterOptionsModal");
        const openFilterOptionsBtn = document.getElementById(
          "openFilterOptionsBtn"
        );
        const filterTypeSelect = document.getElementById("filterTypeSelect"); // Novo seletor para tipo de filtro
        const monthFilterGroup = document.getElementById("monthFilterGroup");
        const intervalFilterGroup = document.getElementById(
          "intervalFilterGroup"
        );
        const predefinedFilterGroup = document.getElementById(
          "predefinedFilterGroup"
        );

        const modalMonthFilter = document.getElementById("modalMonthFilter");
        const modalStartDateFilter = document.getElementById(
          "modalStartDateFilter"
        );
        const modalEndDateFilter =
          document.getElementById("modalEndDateFilter");
        const modalPredefinedPeriodFilter = document.getElementById(
          "modalPredefinedPeriodFilter"
        );
        const filterOptionsModalApplyBtn = document.getElementById(
          "filterOptionsModalApplyBtn"
        );
        const filterOptionsModalCancelBtn = document.getElementById(
          "filterOptionsModalCancelBtn"
        );

        // Preenche as opções de meses no modal
        if (modalMonthFilter) {
          modalMonthFilter.innerHTML =
            '<option value="">Todos os Meses</option>';
        }

        const monthYears = [
          ...new Set(
            storedData
              .map((item) => {
                const parts = item.dataEmissao.split("/");
                return parts.length === 3 ? `${parts[1]}/${parts[2]}` : null;
              })
              .filter((val) => val !== null)
          ),
        ];

        monthYears.sort((a, b) => {
          const [monthA, yearA] = a.split("/").map(Number);
          const [monthB, yearB] = b.split("/").map(Number);
          if (yearA !== yearB) return yearA - yearB;
          return monthA - monthB;
        });

        monthYears.forEach((monthYear) => {
          const option = document.createElement("option");
          option.value = monthYear;
          const [monthNum, yearNum] = monthYear.split("/").map(Number);
          const monthName = new Date(yearNum, monthNum - 1).toLocaleString(
            "pt-BR",
            { month: "long" }
          );
          option.text = `${
            monthName.charAt(0).toUpperCase() + monthName.slice(1)
          }/${yearNum}`;
          if (modalMonthFilter) modalMonthFilter.appendChild(option);
        });

        // Função para mostrar/esconder grupos de filtro no modal
        function showFilterGroup(groupToShow) {
          // Esconde todos os grupos de filtro primeiro
          monthFilterGroup.classList.remove("active");
          intervalFilterGroup.classList.remove("active");
          predefinedFilterGroup.classList.remove("active");

          // Limpa os valores de todos os inputs/selects dentro dos grupos
          modalMonthFilter.value = "";
          modalStartDateFilter.value = "";
          modalEndDateFilter.value = "";
          modalPredefinedPeriodFilter.value = "";

          // Ativa o grupo de filtro selecionado
          if (groupToShow === "month") {
            monthFilterGroup.classList.add("active");
          } else if (groupToShow === "interval") {
            intervalFilterGroup.classList.add("active");
          } else if (groupToShow === "predefined") {
            predefinedFilterGroup.classList.add("active");
          }
        }

        // Event listener para abrir o modal de filtros
        if (openFilterOptionsBtn) {
          openFilterOptionsBtn.addEventListener("click", () => {
            // Ao abrir o modal, pré-preenche o tipo de filtro e os valores se houver um filtro ativo
            if (currentMonthFilter) {
              filterTypeSelect.value = "month";
              modalMonthFilter.value = currentMonthFilter;
            } else if (currentStartDateFilter && currentEndDateFilter) {
              filterTypeSelect.value = "interval";
              modalStartDateFilter.value = currentStartDateFilter;
              modalEndDateFilter.value = currentEndDateFilter;
            } else if (currentPredefinedPeriodFilter) {
              filterTypeSelect.value = "predefined";
              modalPredefinedPeriodFilter.value = currentPredefinedPeriodFilter;
            } else {
              filterTypeSelect.value = ""; // Nenhuma opção selecionada por padrão
            }

            // Garante que apenas o grupo relevante seja visível (ou nenhum se não houver filtro ativo)
            showFilterGroup(filterTypeSelect.value);
            filterOptionsModal.style.display = "flex";
          });
        }

        // Event listener para mudança no seletor de tipo de filtro
        if (filterTypeSelect) {
          filterTypeSelect.addEventListener("change", (e) => {
            showFilterGroup(e.target.value);
          });
        }

        // Event listener para o botão Aplicar no modal de filtros
        if (filterOptionsModalApplyBtn) {
          filterOptionsModalApplyBtn.addEventListener("click", () => {
            const selectedFilterType = filterTypeSelect.value;

            // Limpa todos os filtros de período globais antes de aplicar um novo
            currentMonthFilter = "";
            currentStartDateFilter = "";
            currentEndDateFilter = "";
            currentPredefinedPeriodFilter = "";

            if (selectedFilterType === "month") {
              currentMonthFilter = modalMonthFilter.value;
            } else if (selectedFilterType === "interval") {
              currentStartDateFilter = modalStartDateFilter.value;
              currentEndDateFilter = modalEndDateFilter.value;
            } else if (selectedFilterType === "predefined") {
              currentPredefinedPeriodFilter = modalPredefinedPeriodFilter.value;
              if (currentPredefinedPeriodFilter) {
                const { startDate, endDate } = getDatesForPeriod(
                  currentPredefinedPeriodFilter
                );
                currentStartDateFilter = startDate;
                currentEndDateFilter = endDate;
              }
            }

            // Fecha o modal e aplica os filtros
            filterOptionsModal.style.display = "none";
            applyFiltersAndRender(
              document.getElementById("filterInput").value,
              currentMonthFilter,
              currentStartDateFilter,
              currentEndDateFilter
            );
          });
        }

        // Event listener para o botão Cancelar no modal de filtros
        if (filterOptionsModalCancelBtn) {
          filterOptionsModalCancelBtn.addEventListener("click", () => {
            filterOptionsModal.style.display = "none";
          });
        }

        // Listener para o filtro de texto
        document
          .getElementById("filterInput")
          .addEventListener("input", (e) => {
            // Limpa todos os filtros de período quando o filtro de texto é usado
            currentMonthFilter = "";
            currentStartDateFilter = "";
            currentEndDateFilter = "";
            currentPredefinedPeriodFilter = "";
            updateFilterButtonText(); // Atualiza o texto do botão de filtro de período

            applyFiltersAndRender(
              e.target.value,
              currentMonthFilter,
              currentStartDateFilter,
              currentEndDateFilter
            );
            document.getElementById("clearFilter").style.display = e.target
              .value
              ? "inline-block"
              : "none";
          });

        applyFiltersAndRender(
          document.getElementById("filterInput").value,
          currentMonthFilter,
          currentStartDateFilter,
          currentEndDateFilter
        ); // Aplica filtros e renderiza a tabela e o gráfico
        toggleButtons(); // Chama toggleButtons após o storedData ser inicializado
        updateActionButtonsVisibility(); // Garante que os botões de ação em massa sejam atualizados no carregamento

        // Adiciona listener para a imagem do rodapé APÓS o DOM estar pronto
        const footerImage = document.getElementById("footerImage");
        if (footerImage) {
          footerImage.addEventListener("click", () =>
            swapFooterImage(footerImage)
          );
        }

        // Adiciona listener para o novo botão de alternar modo de edição
        const toggleEditModeBtn = document.getElementById("toggleEditModeBtn");
        if (toggleEditModeBtn) {
          toggleEditModeBtn.addEventListener("click", toggleEditMode);
        }

        // Event listener para manipulação de checkboxes na tabela
        const historyTable = document.getElementById("historyTable");
        if (historyTable) {
          historyTable.addEventListener("click", (e) => {
            // Manipulação de checkboxes (selecionar/desselecionar)
            if (e.target.matches(".row-checkbox")) {
              const checkbox = e.target;
              const mtrId = checkbox.dataset.mtrId;
              const dateId = checkbox.dataset.dateId;
              const uniqueId = `${mtrId}_${dateId}`;

              if (checkbox.checked) {
                selectedMTRs.add(uniqueId);
              } else {
                selectedMTRs.delete(uniqueId);
              }
              updateActionButtonsVisibility();
              // Atualiza o checkbox "Selecionar Todos"
              const allCheckboxes = document.querySelectorAll(".row-checkbox");
              const selectAllCheckbox =
                document.getElementById("selectAllCheckbox");
              if (selectAllCheckbox) {
                selectAllCheckbox.checked =
                  selectedMTRs.size === allCheckboxes.length &&
                  allCheckboxes.length > 0;
              }
            } else if (e.target.matches("#selectAllCheckbox")) {
              const selectAllCheckbox = e.target;
              const allCheckboxes = document.querySelectorAll(".row-checkbox");
              selectedMTRs.clear();
              allCheckboxes.forEach((cb) => {
                cb.checked = selectAllCheckbox.checked;
                if (selectAllCheckbox.checked) {
                  selectedMTRs.add(`${cb.dataset.mtrId}_${cb.dataset.dateId}`);
                }
              });
              updateActionButtonsVisibility();
            }
          });
        }

        // --- Gerenciamento de Ações em Massa de Grupo (antigo) ---
        // Este modal ainda existe, mas sua funcionalidade é mais específica agora para "grupo"
        const editSelectedBtn = document.getElementById("editSelectedBtn"); // Botão para editar grupo de selecionados
        const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
        const bulkEditModal = document.getElementById("bulkEditModal"); // Modal de edição de grupo
        const bulkEditGroupInput =
          document.getElementById("bulkEditGroupInput");
        const bulkEditModalSaveBtn = document.getElementById(
          "bulkEditModalSaveBtn"
        );
        const bulkEditModalCancelBtn = document.getElementById(
          "bulkEditModalCancelBtn"
        );
        const bulkEditSelectedCountSpan = document.getElementById(
          "bulkEditSelectedCount"
        );

        editSelectedBtn.addEventListener("click", () => {
          if (selectedMTRs.size === 0) {
            showAlertModal("Nenhum MTR selecionado para editar.", "no_data");
            return;
          }
          bulkEditSelectedCountSpan.textContent = selectedMTRs.size;
          bulkEditGroupInput.value = ""; // Limpa o input
          bulkEditModal.style.display = "flex"; // Mostra o modal
          bulkEditGroupInput.focus();
        });

        // Adiciona listeners para Enter e Esc no input do modal de edição de grupo
        if (bulkEditGroupInput) {
          bulkEditGroupInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              bulkEditModalSaveBtn.click();
            } else if (e.key === "Escape") {
              e.preventDefault();
              bulkEditModalCancelBtn.click();
            }
          });
        }

        bulkEditModalSaveBtn.addEventListener("click", () => {
          const newGroup = bulkEditGroupInput.value.trim();
          let changesMade = 0;
          storedData = storedData.map((item) => {
            const uniqueId = `${item.mtrFormatted}_${item.dataEmissao}`;
            if (selectedMTRs.has(uniqueId)) {
              if (item.grupo !== newGroup) {
                // Apenas atualiza se houver mudança
                item.grupo = newGroup;
                changesMade++;
              }
            }
            return item;
          });
          localStorage.setItem("residuosData", JSON.stringify(storedData));
          bulkEditModal.style.display = "none";
          selectedMTRs.clear(); // Limpa seleção após a ação
          applyFiltersAndRender(
            document.getElementById("filterInput").value,
            currentMonthFilter,
            currentStartDateFilter,
            currentEndDateFilter
          );
          showAlertModal(
            `${changesMade} MTR(s) tiveram o grupo atualizado.`,
            "success"
          );
          updateActionButtonsVisibility();
          const selectAllCheckbox =
            document.getElementById("selectAllCheckbox");
          if (selectAllCheckbox) selectAllCheckbox.checked = false; // Desseleciona "selecionar todos"
        });

        bulkEditModalCancelBtn.addEventListener("click", () => {
          bulkEditModal.style.display = "none";
        });

        deleteSelectedBtn.addEventListener("click", () => {
          if (selectedMTRs.size === 0) {
            showAlertModal("Nenhum MTR selecionado para excluir.", "no_data");
            return;
          }
          showConfirmModal(
            `Tem certeza que deseja excluir ${selectedMTRs.size} MTR(s) selecionado(s)? Esta ação não pode ser desfeita.`,
            (confirmed) => {
              if (confirmed) {
                const originalLength = storedData.length;
                storedData = storedData.filter((item) => {
                  const uniqueId = `${item.mtrFormatted}_${item.dataEmissao}`;
                  return !selectedMTRs.has(uniqueId);
                });
                const deletedCount = originalLength - storedData.length;
                localStorage.setItem(
                  "residuosData",
                  JSON.stringify(storedData)
                );
                selectedMTRs.clear(); // Limpa seleção após a ação
                applyFiltersAndRender(
                  document.getElementById("filterInput").value,
                  currentMonthFilter,
                  currentStartDateFilter,
                  currentEndDateFilter
                );
                showAlertModal(
                  `${deletedCount} MTR(s) excluído(s) com sucesso.`,
                  "success"
                );
                toggleButtons(); // Atualiza a visibilidade dos botões gerais (limpar histórico, etc.)
                updateActionButtonsVisibility();
                const selectAllCheckbox =
                  document.getElementById("selectAllCheckbox");
                if (selectAllCheckbox) selectAllCheckbox.checked = false; // Desseleciona "selecionar todos"
              }
            }
          );
        });

        // --- Novo Gerenciamento de Edição em Lote (genérico) ---
        const batchEditBtn = document.getElementById("batchEditBtn");
        const batchEditBatchModal = document.getElementById(
          "batchEditBatchModal"
        );
        const batchEditFieldSelect = document.getElementById(
          "batchEditFieldSelect"
        );
        const batchEditValueInput = document.getElementById(
          "batchEditValueInput"
        );
        const batchEditModalSaveBtn = document.getElementById(
          "batchEditModalSaveBtn"
        );
        const batchEditModalCancelBtn = document.getElementById(
          "batchEditModalCancelBtn"
        );
        const batchEditCountModalSpan = document.getElementById(
          "batchEditCountModal"
        );

        if (batchEditBtn) {
          batchEditBtn.addEventListener("click", () => {
            if (selectedMTRs.size === 0) {
              showAlertModal(
                "Nenhum MTR selecionado para edição em lote.",
                "no_data"
              );
              return;
            }
            batchEditCountModalSpan.textContent = selectedMTRs.size;
            batchEditFieldSelect.value = ""; // Reseta seleção do campo
            batchEditValueInput.value = ""; // Limpa o input de valor
            batchEditValueInput.style.display = "none"; // Esconde o input de valor inicialmente
            batchEditBatchModal.style.display = "flex"; // Mostra o modal
          });
        }

        if (batchEditFieldSelect) {
          batchEditFieldSelect.addEventListener("change", () => {
            if (batchEditFieldSelect.value) {
              batchEditValueInput.style.display = "block";
              batchEditValueInput.focus();
            } else {
              batchEditValueInput.style.display = "none";
              batchEditValueInput.value = "";
            }
          });
        }

        // Adiciona listeners para Enter e Esc no input do modal de edição em lote
        if (batchEditValueInput) {
          batchEditValueInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              batchEditModalSaveBtn.click();
            } else if (e.key === "Escape") {
              e.preventDefault();
              batchEditModalCancelBtn.click();
            }
          });
        }

        if (batchEditModalSaveBtn) {
          batchEditModalSaveBtn.addEventListener("click", () => {
            const fieldToUpdate = batchEditFieldSelect.value;
            const newValue = batchEditValueInput.value.trim();

            if (!fieldToUpdate) {
              showAlertModal(
                "Por favor, selecione um campo para editar.",
                "error"
              );
              return;
            }

            // Esconde o modal de edição em lote antes de mostrar o de confirmação
            batchEditBatchModal.style.display = "none";

            showConfirmModal(
              `Tem certeza que deseja alterar o campo '${fieldToUpdate}' para '${newValue}' em ${selectedMTRs.size} MTR(s) selecionado(s)? Esta ação não pode ser desfeita.`,
              (confirmed) => {
                if (confirmed) {
                  let changesMade = 0;
                  storedData = storedData.map((item) => {
                    const uniqueId = `${item.mtrFormatted}_${item.dataEmissao}`;
                    if (selectedMTRs.has(uniqueId)) {
                      if (item[fieldToUpdate] !== newValue) {
                        // Atualiza apenas se houver mudança
                        // Validação específica para campos numéricos durante a edição em lote
                        if (
                          fieldToUpdate === "litros" ||
                          fieldToUpdate === "toneladas"
                        ) {
                          const parsedValue = parseFloat(
                            newValue.replace(",", ".")
                          );
                          if (isNaN(parsedValue)) {
                            console.error(
                              `Valor inválido para ${fieldToUpdate}. Mantendo valor original.`
                            );
                            // Não altere o item se o valor for inválido, mas não bloqueie todo o processo
                            return item;
                          }
                        }
                        item[fieldToUpdate] = newValue;
                        changesMade++;
                      }
                    }
                    return item;
                  });
                  localStorage.setItem(
                    "residuosData",
                    JSON.stringify(storedData)
                  );
                  batchEditBatchModal.style.display = "none";
                  selectedMTRs.clear(); // Limpa seleção após a ação
                  applyFiltersAndRender(
                    document.getElementById("filterInput").value,
                    currentMonthFilter,
                    currentStartDateFilter,
                    currentEndDateFilter
                  );
                  showAlertModal(
                    `${changesMade} MTR(s) tiveram o campo '${fieldToUpdate}' atualizado.`,
                    "success"
                  );
                  updateActionButtonsVisibility();
                  const selectAllCheckbox =
                    document.getElementById("selectAllCheckbox");
                  if (selectAllCheckbox) selectAllCheckbox.checked = false; // Desseleciona "selecionar todos"
                } else {
                  // Se o usuário cancelar a confirmação, mostra o modal de edição em lote novamente
                  batchEditBatchModal.style.display = "flex";
                }
              }
            );
          });
        }

        if (batchEditModalCancelBtn) {
          batchEditModalCancelBtn.addEventListener("click", () => {
            batchEditBatchModal.style.display = "none";
          });
        }

        updateActionButtonsVisibility(); // Chamada inicial para definir o estado dos botões
      }); // Fechamento do DOMContentLoaded
    </script>
  </body>
</html>
