<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relatório de Resíduos Gerados</title>
    <!-- Metadados para SEO e Descrição da Página -->
    <meta
      name="description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta name="author" content="Jhon Randler" />
    <meta
      name="keywords"
      content="gestão de resíduos, relatório de resíduos, PDF, extração de dados, MTR, histórico de resíduos, ferramenta gratuita"
    />

    <!-- Open Graph Metadados para Redes Sociais (Facebook, WhatsApp, LinkedIn) -->
    <meta property="og:title" content="Relatório de Resíduos Gerados" />
    <meta
      property="og:description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://jhonnierandler.github.io/relatorio-de-residuos"
    />
    <!-- IMPORTANTE: Usar URL absoluta para a imagem para funcionar no WhatsApp e outras plataformas -->
    <!-- Ajustado para o tamanho real da imagem (408x408) -->
    <meta
      property="og:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta property="og:image:width" content="408" />
    <meta property="og:image:height" content="408" />
    <meta property="og:locale" content="pt_BR" />

    <!-- Twitter Card Metadados -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Relatório de Resíduos Gerados" />
    <meta
      name="twitter:description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta
      name="twitter:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta name="twitter:creator" content="@JhonnieRandler" />
    <!-- Altere @SeuHandleTwitter para o seu handle do Twitter, se tiver um -->

    <link rel="icon" type="image/png" href="footer.png" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- Preload das imagens para carregamento mais rápido -->
    <link rel="preload" as="image" href="doubt.png" />
    <link rel="preload" as="image" href="footer.png" />
    <link rel="preload" as="image" href="blink.png" />
    <link rel="preload" as="image" href="like.png" />
    <link rel="preload" as="image" href="point.png" />
    <link rel="preload" as="image" href="sure.png" />
    <!-- Preload do áudio -->
    <link rel="preload" as="audio" href="blink.mp3" />
    <style>
      :root {
        /* Cores do tema claro */
        --background-color: #f5f5f5;
        --text-color: #333;
        --header-color: #333;
        --button-bg-color: #ffffff;
        --button-text-color: #333;
        --button-hover-bg-color: #4caf50;
        --button-hover-text-color: white;
        --table-header-bg: #e0e0e0;
        --table-border-color: #ccc;
        --table-row-bg: #ffffff;
        --modal-bg-color: #fefefe;
        --footer-bg-color: #ffcead;
        --box-shadow-color: rgba(0, 0, 0, 0.1);

        /* Novas variáveis para o overlay de drag */
        --overlay-bg-transparent: rgba(
          255,
          206,
          173,
          0.7
        ); /* Cor do rodapé com 70% de opacidade */
        --overlay-border-color: rgba(
          255,
          255,
          255,
          0.9
        ); /* Borda clara mais opaca (90%) */
        --drag-overlay-text: #333; /* Cor do texto no overlay claro */

        /* Cores específicas para o botão de tema no modo claro */
        --theme-toggle-normal-bg: #ffffff;
        --theme-toggle-normal-color: #333;
        --theme-toggle-hover-bg: #000000;
        --theme-toggle-hover-color: #ffffff;
      }

      [data-theme="dark"] {
        /* Cores do tema noturno */
        --background-color: #1a1a1a;
        --text-color: #e0e0e0;
        --header-color: #f5f5f5;
        --button-bg-color: #333333;
        --button-text-color: #e0e0e0;
        --button-hover-bg-color: #367d39;
        --button-hover-text-color: white;
        --table-header-bg: #444444;
        --table-border-color: #555;
        --table-row-bg: #2b2b2b;
        --modal-bg-color: #333333;
        --footer-bg-color: #3d2a21; /* Um marrom mais escuro para o rodapé */
        --box-shadow-color: rgba(255, 255, 255, 0.1);

        /* Novas variáveis para o overlay de drag no tema escuro */
        --overlay-bg-transparent: rgba(
          61,
          42,
          33,
          0.7
        ); /* Cor do rodapé escuro com 70% de opacidade */
        --overlay-border-color: rgba(
          255,
          255,
          255,
          0.7
        ); /* Borda clara semi-transparente para tema escuro (70%) */
        --drag-overlay-text: #e0e0e0; /* Cor do texto no overlay escuro */

        /* Cores específicas para o botão de tema no modo noturno */
        --theme-toggle-normal-bg: #333333;
        --theme-toggle-normal-color: #e0e0e0;
        --theme-toggle-hover-bg: #ffffff;
        --theme-toggle-hover-color: #ffa500; /* Laranja/Amarelo */
      }

      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%; /* Garante que body ocupe 100% da largura para o blur */
        overflow-x: hidden;
      }
      /* Adiciona box-sizing universal para um modelo de caixa consistente */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        font-family: Arial, sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        transition: background-color 0.3s ease, color 0.3s ease,
          filter 0.3s ease; /* Adiciona transição para o filtro */
        position: relative; /* Necessário para posicionar o overlay */
      }
      body.blur-active > *:not(#dragDropOverlay) {
        /* Aplica blur a todos os filhos do body, exceto o overlay */
        filter: blur(5px);
        pointer-events: none; /* Desabilita interações com elementos borrados */
      }
      main {
        flex: 1 0 auto;
        width: 100%;
        max-width: 95%;
        margin: 20px auto;
        padding: 0 20px;
        text-align: center;
      }
      h1 {
        color: var(--header-color);
        margin-bottom: 20px;
      }
      .input-container {
        display: flex;
        justify-content: center;
        margin: 20px 0;
      }
      input[type="file"] {
        display: none;
      }
      .custom-file-upload {
        display: inline-block;
        padding: 12px 20px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      .custom-file-upload:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      #textOutput {
        margin-top: 20px;
      }
      /* Novo estilo para o indicador de progresso */
      #progressIndicator {
        margin-top: 10px;
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        min-height: 3em; /* Ajustado para acomodar duas linhas de texto */
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #progressIndicator span {
        display: block; /* Garante que cada parte esteja em sua própria linha */
      }

      .table-container {
        overflow-x: auto;
        width: 100%;
        margin-bottom: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        background-color: var(--table-row-bg);
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        color: var(--text-color);
      }
      th,
      td {
        border: 1px solid var(--table-border-color);
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: var(--table-header-bg);
        font-weight: bold;
      }
      button {
        padding: 10px 20px;
        margin: 10px 0;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      button:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      .history-button {
        margin: 10px 0;
        padding: 10px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      .history-button:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      #error,
      #messageBox {
        color: red;
        background-color: #ffe0e0;
        border: 1px solid red;
        padding: 10px;
        margin-top: 10px;
        border-radius: 8px;
        display: none;
      }
      #messageBox.success {
        color: green;
        background-color: #e0ffe0;
        border-color: green;
      }
      footer {
        flex: 0 0 auto;
        width: 100%;
        background-color: var(--footer-bg-color);
        padding: 15px;
        text-align: center;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 15px;
        box-sizing: border-box;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      footer img {
        max-width: 100px;
        height: auto;
        cursor: pointer;
      }
      footer p {
        color: var(--text-color);
        font-size: 14px;
        margin: 0;
        flex: 1;
        overflow-wrap: break-word;
      }
      .theme-toggle-button {
        background-color: var(--theme-toggle-normal-bg);
        color: var(--theme-toggle-normal-color);
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        cursor: pointer;
        font-size: 18px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        transition: background-color 0.3s ease, color 0.3s ease, transform 0.2s,
          box-shadow 0.3s ease;
        margin-left: 10px;
      }

      .theme-toggle-button:hover {
        background-color: var(--theme-toggle-hover-bg);
        color: var(--theme-toggle-hover-color);
        transform: translateY(-2px);
      }
      .header-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 20px;
      }
      @media screen and (max-width: 600px) {
        main {
          padding: 10px;
        }
        h1 {
          font-size: 24px;
        }
        .custom-file-upload {
          padding: 10px 16px;
          font-size: 14px;
        }
        th,
        td {
          padding: 5px;
          font-size: 13px;
        }
        button {
          padding: 8px 16px;
          font-size: 14px;
        }
        .history-button {
          padding: 8px;
          font-size: 14px;
        }
        footer {
          flex-direction: column;
          padding: 10px 15px;
        }
        footer img {
          max-width: 80px;
          margin-bottom: 10px;
        }
        footer p {
          font-size: 12px;
          max-width: 100%;
        }
        .header-controls {
          flex-direction: column;
          gap: 10px;
        }
      }

      /* Estilos para Modais de Alerta e Confirmação */
      .modal-overlay {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background-color: var(--modal-bg-color);
        margin: auto;
        padding: 20px;
        border: 1px solid var(--table-border-color);
        width: 80%;
        max-width: 400px;
        border-radius: 10px;
        box-shadow: 0 4px 8px var(--box-shadow-color);
        text-align: center;
        color: var(--text-color);
        transition: background-color 0.3s ease, border-color 0.3s ease,
          box-shadow 0.3s ease, color 0.3s ease;
      }

      .modal-buttons button {
        padding: 10px 15px;
        margin: 10px 5px 0;
        border-radius: 5px;
        cursor: pointer;
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        border: none;
        transition: background-color 0.3s ease, opacity 0.3s ease;
      }

      .modal-buttons button:hover {
        opacity: 0.9;
      }
      .modal-image {
        max-width: 80px;
        height: auto;
        margin-bottom: 15px;
        display: none;
        margin: 0 auto 15px auto;
      }
      /* Estilo específico para o botão de cancelar no modal de confirmação */
      #folderModalCancelBtn {
        background-color: #f44336; /* Vermelho para cancelar */
      }
      #folderModalCancelBtn:hover {
        background-color: #d32f2f;
      }

      /* Estilos para o overlay de Drag and Drop */
      #dragDropOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(
          --overlay-bg-transparent
        ); /* Usando nova variável */
        padding: 20px; /* Padding para que a borda interna não encoste nas bordas da tela */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 999;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease, background-color 0.3s ease; /* Transições para suavidade */
        box-sizing: border-box; /* Garante que padding e border não aumentem o tamanho total */
      }

      #dragDropOverlay.active {
        opacity: 1;
        pointer-events: all;
      }

      #dragDropArea {
        width: 100%; /* Ocupa a largura disponível dentro do padding do overlay */
        height: 100%; /* Ocupa a altura disponível dentro do padding do overlay */
        border: 12px dashed var(--overlay-border-color); /* Borda grossa, tracejada e mais opaca */
        border-radius: 25px; /* Bordas arredondadas */
        display: flex;
        justify-content: center;
        align-items: center;
        transition: border-color 0.3s ease; /* Transição para a cor da borda */
      }

      #dragDropOverlay p {
        color: var(--drag-overlay-text);
        font-size: 3.5em; /* Aumentado para 'bem grande' */
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* Sombra para o texto */
        padding: 0; /* Removido padding para o texto */
        margin: 0; /* Garante que não haja margem adicional no texto */
        text-align: center; /* Centraliza o texto */
      }
      @media screen and (max-width: 600px) {
        #dragDropOverlay p {
          font-size: 2em; /* Reduz o tamanho da fonte em telas menores */
        }
      }
    </style>
  </head>
  <body>
    <div id="dragDropOverlay">
      <div id="dragDropArea">
        <p>Solte o MTR em qualquer lugar</p>
      </div>
    </div>

    <main id="mainContent">
      <div class="header-controls">
        <h1>Relatório de Resíduos Gerados</h1>
        <button id="themeToggle" class="theme-toggle-button">
          <i class="fas fa-moon"></i>
        </button>
      </div>
      <div class="input-container">
        <label for="pdfInput" class="custom-file-upload">
          <i class="fas fa-upload"></i> Selecionar PDFs
        </label>
        <input type="file" id="pdfInput" accept="application/pdf" multiple />
      </div>
      <button
        class="history-button"
        id="historyButton"
        onclick="window.location.href='historico/'"
      >
        <i class="fas fa-history"></i> Histórico
      </button>
      <div id="textOutput"></div>
      <div id="progressIndicator"></div>
      <!-- Novo elemento para o indicador de progresso -->
      <div id="error"></div>
      <div id="messageBox"></div>
      <!-- Adicionado para mensagens de sucesso/erro -->
    </main>
    <footer>
      <img id="footerImage" src="footer.png" alt="Footer Image" />
      <p>
        Este site foi desenvolvido para facilitar a gestão de resíduos gerados,
        oferecendo uma ferramenta prática e acessível. É livre para uso por
        todos!
      </p>
      <!-- Elemento de áudio para o som de blink -->
      <audio id="blinkAudio" preload="auto">
        <source src="blink.mp3" type="audio/mpeg" />
        Seu navegador não suporta o elemento de áudio.
      </audio>
    </footer>

    <!-- Modal de Alerta Customizado (para erros e mensagens gerais) -->
    <div id="customAlertModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="alertModalImage"
          src=""
          alt="Ícone de Status"
          class="modal-image"
        />
        <p id="alertMessage"></p>
        <div class="modal-buttons">
          <button id="alertOkBtn">OK</button>
        </div>
      </div>
    </div>

    <!-- Novo Modal de Confirmação para Pastas -->
    <div id="folderConfirmModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="folderConfirmModalImage"
          src="point.png"
          alt="Ícone de Aviso"
          class="modal-image"
        />
        <p id="folderModalMessage"></p>
        <div class="modal-buttons">
          <button id="folderModalConfirmBtn">Sim</button>
          <button id="folderModalCancelBtn">Não</button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      // Configura o worker do PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

      // Função para alternar o tema
      function toggleTheme() {
        const htmlElement = document.documentElement;
        const currentTheme = htmlElement.getAttribute("data-theme");
        const themeToggleBtn = document.getElementById("themeToggle");

        if (currentTheme === "dark") {
          htmlElement.removeAttribute("data-theme");
          localStorage.setItem("theme", "light");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        } else {
          htmlElement.setAttribute("data-theme", "dark");
          localStorage.setItem("theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        }
      }

      // Função para aplicar o tema salvo
      function applySavedTheme() {
        const savedTheme = localStorage.getItem("theme");
        const htmlElement = document.documentElement;
        const themeToggleBtn = document.getElementById("themeToggle");

        if (savedTheme === "dark") {
          htmlElement.setAttribute("data-theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        } else {
          htmlElement.removeAttribute("data-theme");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        }
      }

      // Envolve todo o código principal em um listener DOMContentLoaded
      document.addEventListener("DOMContentLoaded", () => {
        applySavedTheme(); // Aplica o tema salvo ao carregar a página

        const themeToggleBtn = document.getElementById("themeToggle");
        if (themeToggleBtn) {
          themeToggleBtn.addEventListener("click", toggleTheme);
        }

        // Mapeamento de códigos IBAMA para tipos, ajustado para consistência
        const ibamaCodeToType = {
          191213: "NÃO RECICLÁVEL",
          150202: "CONTAMINADO",
          "030101": "MADEIRA",
          "030301": "MADEIRA",
          "030308": "PAPEL",
          200139: "PLÁSTICO",
          200108: "ORGÂNICO",
          170503: "SOLO CONTAMINADO",
          170407: "SUCATA FERROSA",
          190899: "EFLUENTE SANITÁRIO",
          130201: "ÓLEO QUEIMADO",
          130507: "ÁGUA E ÓLEO",
        };
        const rccCodes = [
          "170201",
          "170202",
          "170203",
          "170401",
          "170402",
          "170403",
          "170404",
          "170405",
          "170406",
          "170411",
          "170412",
          "170413",
          "170802",
        ];

        // Função para exibir modais de alerta com imagem (para erros e mensagens gerais)
        function showAlertModal(message, type) {
          // type: 'success', 'exists', 'no_data', 'error'
          const modal = document.getElementById("customAlertModal");
          const alertMessage = document.getElementById("alertMessage");
          const alertModalImage = document.getElementById("alertModalImage");
          const okBtn = document.getElementById("alertOkBtn");

          if (alertMessage) alertMessage.textContent = message;
          if (modal) modal.classList.remove("success", "error"); // Limpa classes anteriores para evitar conflitos

          let imagePath = "";
          if (type === "success") {
            imagePath = "like.png";
            if (okBtn) okBtn.style.backgroundColor = "#4CAF50"; // Verde para sucesso
          } else if (type === "exists") {
            imagePath = "point.png";
            if (okBtn) okBtn.style.backgroundColor = "#FFA000"; // Laranja para "já existente"
          } else if (type === "no_data" || type === "error") {
            imagePath = "doubt.png";
            if (okBtn) okBtn.style.backgroundColor = "#f44336"; // Vermelho para erro/falha
          }

          if (alertModalImage) {
            alertModalImage.src = imagePath;
            alertModalImage.style.display = "block";
          }

          if (modal) modal.style.display = "flex";

          const handleOk = () => {
            if (modal) modal.style.display = "none";
            if (okBtn) okBtn.removeEventListener("click", handleOk);
            if (alertModalImage) alertModalImage.style.display = "none"; // Oculta a imagem ao fechar
          };
          if (okBtn) okBtn.addEventListener("click", handleOk);
        }

        // Nova função para o modal de confirmação de pasta
        function showFolderConfirmModal(message) {
          return new Promise((resolve) => {
            const modal = document.getElementById("folderConfirmModal");
            const modalMessage = document.getElementById("folderModalMessage");
            const confirmModalImage = document.getElementById(
              "folderConfirmModalImage"
            );
            const confirmBtn = document.getElementById("folderModalConfirmBtn");
            const cancelBtn = document.getElementById("folderModalCancelBtn");

            // Garante que os listeners anteriores sejam removidos para evitar múltiplos disparos
            // Clonar e substituir o botão é uma forma robusta de remover listeners antigos
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            if (modalMessage) modalMessage.textContent = message;
            if (confirmModalImage) {
              confirmModalImage.src = "point.png"; // Ícone de "ponto de atenção"
              confirmModalImage.style.display = "block";
            }
            if (modal) modal.style.display = "flex";

            const handleConfirm = () => {
              resolve(true);
              if (modal) modal.style.display = "none";
              if (confirmModalImage) confirmModalImage.style.display = "none";
            };

            const handleCancel = () => {
              resolve(false);
              if (modal) modal.style.display = "none";
              if (confirmModalImage) confirmModalImage.style.display = "none";
            };

            newConfirmBtn.addEventListener("click", handleConfirm);
            newCancelBtn.addEventListener("click", handleCancel);
          });
        }

        // Função para extrair dados do texto (usada por processPdfFile)
        async function extractData(text) {
          const extracted = {};

          const dataEmissaoMatch = text.match(
            /Data\s*da\s*emissão:?\s*(\d{2}\/\d{2}\/\d{4})/i
          );
          extracted.dataEmissao = dataEmissaoMatch
            ? dataEmissaoMatch[1]
            : "Não encontrada";

          // Modificação: Ajusta a regex para capturar MTR nº/n° ou MTR sem número
          const mtrMatch = text.match(/MTR\s*n[ºo°]:?\s*(\d+)/i);
          extracted.mtr = mtrMatch ? mtrMatch[1] : "Não encontrado";
          extracted.mtrFormatted = mtrMatch
            ? `MTR nº: ${mtrMatch[1]}`
            : "Não encontrado";

          // CORREÇÃO AQUI: Torna o "Ticket " opcional e lida com "nº" ou "n°" e espaços
          const mtrRefMatch = text.match(
            /Referente\s*ao\s*(?:Ticket\s*)?(?:MTR|CCO)\s*(?:n[ºo°]\s*)?(\d+)/i
          );
          extracted.mtrRef = mtrRefMatch ? mtrRefMatch[1] : "N/A";

          const razaoInicialMatches = text.matchAll(
            /Raz[ãa]o\s*Social:?\s*([^:]+?)(?=\s*(?:Raz[ãa]o\s*Social|Telefone|Endereço|$))/gi
          );
          let razoesIniciais = Array.from(razaoInicialMatches, (match) =>
            match[1].trim().split("-")[0].trim()
          );

          const razaoDestinadorMatch = text.match(
            /Identificação\s*do\s*Destinador.*?Raz[ãa]o\s*Social:?\s*([^:]+?)(?=\s*(?:Estado|Município|$))/is
          );
          const razaoDestinador = razaoDestinadorMatch
            ? razaoDestinadorMatch[1].trim().split("-")[0].trim()
            : null;

          let razoesSociais = [...razoesIniciais];
          if (razaoDestinador) razoesSociais.push(razaoDestinador);
          razoesSociais = razoesSociais.filter(
            (razao) =>
              !razao
                .toUpperCase()
                .includes("CONSORCIO CONSTRUTOR FERROVIA LUCAS DO RIO VERDE")
          );

          extracted.razaoSocial1 =
            razoesSociais.length > 0 ? razoesSociais[0] : "Não encontrada";
          extracted.razaoSocial2 =
            razoesSociais.length > 1
              ? razoesSociais[1]
              : razoesSociais.length === 1
              ? razoesSociais[0]
              : "Não encontrada";

          const estadoFisicoMatch = text.match(/.*?(SÓLIDO|LÍQUIDO)\s*CLASSE/i);
          extracted.estadoFisico = estadoFisicoMatch
            ? estadoFisicoMatch[1]
            : "Não encontrado";

          const quantidadeMatch = text.match(/Qtde.*?(\d+,\d{4})/i);
          let quantidade = quantidadeMatch
            ? quantidadeMatch[1]
            : "Não encontrada";

          const unidadeMatch = text.match(/\s(KG|TON)\s/i);
          const unidade = unidadeMatch ? unidadeMatch[1].toUpperCase() : "";

          const ibamaMatch = text.match(
            /Código\s*IBAMA\s*e\s*Denominação.*?(\d{6}(?:\(*\))?)/is
          );
          const ibamaCode = ibamaMatch
            ? ibamaMatch[1].replace(/\(.*\)/, "").trim()
            : "Não encontrado";
          if (ibamaCode === "Não encontrado") {
            extracted.tipo = "Não encontrado";
          } else if (ibamaCodeToType[ibamaCode]) {
            extracted.tipo = ibamaCodeToType[ibamaCode];
          } else if (rccCodes.includes(ibamaCode)) {
            extracted.tipo = "RCC";
          } else {
            extracted.tipo = ibamaCode;
          }

          // Nova lógica: Se o tipo for "ÓLEO QUEIMADO", sempre use toneladas
          if (extracted.tipo === "ÓLEO QUEIMADO") {
            extracted.litros = "";
            extracted.toneladas = quantidade;
          } else {
            extracted.litros =
              extracted.estadoFisico === "LÍQUIDO" ? quantidade : "";
            extracted.toneladas =
              extracted.estadoFisico === "SÓLIDO" ? quantidade : "";
          }

          if (
            extracted.toneladas &&
            unidade === "KG" &&
            extracted.tipo === "RCC"
          ) {
            extracted.toneladas = (
              parseFloat(quantidade.replace(",", ".")) / 1000
            )
              .toFixed(4)
              .replace(".", ",");
          }

          return extracted;
        }

        // Função para processar um único arquivo PDF
        async function processPdfFile(file) {
          // Verifica o tipo de arquivo antes de carregar
          if (file.type !== "application/pdf") {
            throw new new Error("not-pdf")(); // Mudança aqui: new Error("not-pdf")
          }

          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          if (pdf.numPages > 1) {
            throw new Error("multi-page-pdf"); // Erro customizado para PDFs com mais de uma página
          }

          let fullText = "";
          const page = await pdf.getPage(1); // Processa apenas a primeira página
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map((item) => item.str).join(" ");
          fullText += pageText + " ";

          return extractData(fullText); // Chama a função extractData
        }

        // Função para trocar a imagem do rodapé e reproduzir áudio
        function swapFooterImage(imgElement) {
          const originalSrc = imgElement.src;
          const blinkSrc = originalSrc.replace("footer.png", "blink.png");
          const audio = document.getElementById("blinkAudio");

          imgElement.src = blinkSrc;
          if (audio) {
            audio.currentTime = 0; // Reinicia o áudio se já estiver tocando
            audio
              .play()
              .catch((e) => console.error("Erro ao reproduzir áudio:", e));
          }
          setTimeout(() => {
            imgElement.src = originalSrc;
          }, 400); // Alterado para 400 milissegundos
        }

        // Função para copiar texto para a área de transferência
        function copyToClipboard(text) {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          // Torna o textarea invisível
          textarea.style.position = "fixed";
          textarea.style.top = "0";
          textarea.style.left = "0";
          textarea.style.width = "1em";
          textarea.style.height = "1em";
          textarea.style.border = "none";
          textarea.style.outline = "none";
          textarea.style.boxShadow = "none";
          textarea.style.background = "transparent";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            const successful = document.execCommand("copy");
            return successful;
          } catch (err) {
            console.error("Erro ao copiar:", err);
            return false;
          } finally {
            document.body.removeChild(textarea);
          }
        }

        /**
         * Recursively reads entries from a directory.
         * @param {FileSystemDirectoryEntry} directoryEntry The directory entry.
         * @param {Array<File>} filesArray The array to accumulate files.
         * @param {Set<string>} uniqueFileIdentifiers Set to track unique files by identifier.
         * @returns {Promise<void>} A promise that resolves when all files are read.
         */
        async function readDirectoryEntries(
          directoryEntry,
          filesArray,
          uniqueFileIdentifiers
        ) {
          return new Promise((resolve) => {
            const directoryReader = directoryEntry.createReader();
            let entries = [];

            const readBatch = () => {
              directoryReader.readEntries(async (batch) => {
                if (!batch.length) {
                  // No more entries, process them
                  for (const entry of entries) {
                    if (entry.isFile) {
                      const file = await new Promise((res) => entry.file(res));
                      if (file) {
                        // Use a more robust identifier for uniqueness
                        const identifier = `${file.name}-${file.size}-${file.lastModified}`;
                        if (!uniqueFileIdentifiers.has(identifier)) {
                          filesArray.push(file);
                          uniqueFileIdentifiers.add(identifier);
                        } else {
                          console.warn(
                            `Arquivo duplicado (dentro da pasta) ignorado: ${file.name}`
                          );
                        }
                      }
                    } else if (entry.isDirectory) {
                      // Chama recursivamente para subdiretórios
                      await readDirectoryEntries(
                        entry,
                        filesArray,
                        uniqueFileIdentifiers
                      );
                    }
                  }
                  resolve();
                } else {
                  entries = entries.concat(Array.from(batch));
                  readBatch(); // Continua lendo o próximo lote
                }
              });
            };
            readBatch();
          });
        }

        // Nova função para lidar com os arquivos ou itens de dataTransfer
        async function handleFiles(source) {
          const textOutput = document.getElementById("textOutput");
          const errorDiv = document.getElementById("error");
          const messageBox = document.getElementById("messageBox");
          const progressIndicator =
            document.getElementById("progressIndicator");

          // Limpa mensagens e indicadores anteriores
          if (textOutput) textOutput.innerHTML = ""; // Limpa a tabela anterior
          if (errorDiv) errorDiv.style.display = "none";
          if (messageBox) {
            messageBox.style.display = "none";
            messageBox.classList.remove(
              "success",
              "error",
              "exists",
              "no_data"
            );
          }
          // Exibe mensagem de carregamento inicial
          if (progressIndicator) {
            progressIndicator.innerHTML = `<span>Carregando arquivos para processamento...</span><span>(Isso pode levar alguns instantes para pastas grandes)</span>`;
          }

          let filesToProcess = [];
          const uniqueFileIdentifiers = new Set(); // Para evitar duplicatas

          // Function to add a file to filesToProcess if it's unique
          function addFileIfUnique(file) {
            const identifier = `${file.name}-${file.size}-${file.lastModified}`;
            if (!uniqueFileIdentifiers.has(identifier)) {
              filesToProcess.push(file);
              uniqueFileIdentifiers.add(identifier);
            } else {
              console.warn(`Arquivo duplicado ignorado: ${file.name}`);
            }
          }

          // Scenario 1: From <input type="file"> (FileList)
          if (source instanceof FileList) {
            console.log("Source is FileList (from input type=file).");
            Array.from(source).forEach((file) => addFileIfUnique(file));
          }
          // Scenario 2: From Drag and Drop (DataTransfer object)
          else if (source instanceof DataTransfer) {
            console.log("Source is DataTransfer (from drag and drop).");

            // Process all dropped items from DataTransfer.items directly
            // This is the most reliable way to distinguish between files and directories.
            for (const item of Array.from(source.items)) {
              // Use webkitGetAsEntry to check if it's a file or directory entry
              if (item.webkitGetAsEntry && item.webkitGetAsEntry()) {
                const entry = item.webkitGetAsEntry();
                if (entry.isFile) {
                  const file = await new Promise((resolve) =>
                    item.getAsFile(resolve)
                  );
                  if (file) {
                    addFileIfUnique(file);
                    console.log(
                      `Adicionado arquivo direto da entrada: ${file.name}`
                    );
                  }
                } else if (entry.isDirectory) {
                  console.log(`Detected directory: ${entry.name}`);
                  const confirmed = await showFolderConfirmModal(
                    `Uma pasta foi detectada: "${entry.name}". Deseja processar os arquivos MTR dentro dela?`
                  );
                  if (confirmed) {
                    // Recursively read files from the directory and add them to filesToProcess
                    await readDirectoryEntries(
                      entry,
                      filesToProcess,
                      uniqueFileIdentifiers
                    );
                    console.log(
                      `Adicionado arquivos da pasta "${entry.name}". Total atual: ${filesToProcess.length}`
                    );
                  } else {
                    console.log(
                      `Processamento da pasta "${entry.name}" cancelado pelo usuário.`
                    );
                  }
                }
              } else if (item.kind === "file" && item.getAsFile) {
                // Fallback for direct file items using getAsFile() if webkitGetAsEntry is not available or returns null
                const file = item.getAsFile();
                if (file) {
                  addFileIfUnique(file);
                  console.log(
                    `Adicionado arquivo via getAsFile (fallback): ${file.name}`
                  );
                }
              }
              // Non-file/non-directory items (e.g., text, URL drags) are naturally ignored here.
            }
          } else {
            showAlertModal(
              "Nenhum arquivo ou pasta foi selecionado ou solto.",
              "no_data"
            );
            if (progressIndicator) progressIndicator.innerHTML = ""; // Clear progress
            return;
          }

          // At this point, filesToProcess should contain only actual File objects (not directories)
          // and unique ones, ready for PDF processing.

          if (filesToProcess.length === 0) {
            showAlertModal(
              "Nenhum arquivo PDF válido encontrado para processar na seleção (ou o processamento das pastas foi cancelado/estavam vazias/não continham PDFs válidos).",
              "no_data"
            );
            if (progressIndicator) progressIndicator.innerHTML = ""; // Clear progress
            return;
          }

          console.log(
            `Total de arquivos PDF únicos a serem processados: ${filesToProcess.length}`
          );

          let extractedDataResults = []; // Stores results of all PDF processing attempts
          let nonPdfCount = 0;
          let multiPageCount = 0;
          let noMtrDataCount = 0; // PDFs that were valid but had no MTR data
          let otherErrorCount = 0; // For errors during PDF loading/parsing
          let processedFileCount = 0; // Counter of processed files

          // Remove loading message and start detailed progress indicator
          if (progressIndicator) {
            progressIndicator.innerHTML = `<span>Processando 0 de ${filesToProcess.length} arquivos...</span><span>(Aguarde...)</span>`;
          }

          for (const file of filesToProcess) {
            processedFileCount++;
            if (progressIndicator) {
              progressIndicator.innerHTML = `<span>Processando arquivo ${processedFileCount} de ${filesToProcess.length}...</span><span>(${file.name})</span>`;
            }
            console.log(`Iniciando processamento de: ${file.name}`);

            try {
              const pdfData = await processPdfFile(file);
              // Add a temporary flag to indicate successful PDF.js processing
              extractedDataResults.push({
                ...pdfData,
                _processedSuccessfully: true,
                _fileName: file.name,
              });
            } catch (error) {
              if (error.message === "multi-page-pdf") {
                multiPageCount++;
                // Register that this file failed due to being multi-page
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "multi-page",
                  _fileName: file.name,
                });
                console.warn(
                  `Arquivo ignorado (mais de uma página): ${file.name}`
                );
              } else if (error.message === "not-pdf") {
                // This is the key part: ONLY increment nonPdfCount if it's an actual File that's not a PDF.
                // Directory entries should never reach this point.
                nonPdfCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "not-pdf",
                  _fileName: file.name,
                });
                console.warn(`Arquivo ignorado (não é PDF): ${file.name}`);
              } else {
                otherErrorCount++;
                // Register that this file failed due to another error
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "other-error",
                  _fileName: file.name,
                  _errorMessage: error.message,
                });
                console.error(`Erro ao processar arquivo ${file.name}:`, error);
              }
            }
          }

          // Clear progress indicator after processing
          if (progressIndicator) {
            progressIndicator.innerHTML = "";
          }

          let storedData = JSON.parse(
            localStorage.getItem("residuosData") || "[]"
          );
          let newUniqueDataCount = 0;
          let existingDuplicatesCount = 0;

          const dataToDisplayInTable = [];

          // Process results to separate valid MTRs, duplicates, and PDFs without MTR data
          extractedDataResults.forEach((item) => {
            if (item._processedSuccessfully) {
              // Remove temporary flags before checking and saving
              const { _processedSuccessfully, _fileName, ...cleanItem } = item;

              // Check if extracted data meets criteria for a "valid MTR"
              if (
                cleanItem.dataEmissao !== "Não encontrada" &&
                cleanItem.mtrFormatted !== "Não encontrado" &&
                cleanItem.razaoSocial1 !== "Não encontrada" &&
                cleanItem.razaoSocial2 !== "Não encontrada" &&
                cleanItem.tipo !== "Não encontrado"
              ) {
                const isDuplicate = storedData.some(
                  (existingItem) =>
                    existingItem.mtrFormatted === cleanItem.mtrFormatted &&
                    existingItem.dataEmissao === cleanItem.dataEmissao
                );

                if (!isDuplicate) {
                  storedData.push(cleanItem); // Add to main list
                  newUniqueDataCount++;
                  dataToDisplayInTable.push(cleanItem); // Add for current table display
                } else {
                  existingDuplicatesCount++;
                  dataToDisplayInTable.push(cleanItem); // Still display duplicates in current table
                }
              } else {
                noMtrDataCount++; // Count PDFs that did not yield valid MTR data
              }
            }
            // Files that failed in processPdfFile are already counted (nonPdfCount, multiPageCount, otherErrorCount)
          });

          // Save updated data to localStorage
          localStorage.setItem("residuosData", JSON.stringify(storedData));

          // Render table ONLY if there is data to display in this execution
          if (dataToDisplayInTable.length > 0) {
            let tableRows = dataToDisplayInTable
              .map(
                (data) => `
                <tr>
                  <td>${data.dataEmissao}</td>
                  <td>${data.mtrFormatted}</td>
                  <td>${data.razaoSocial1}</td>
                  <td>${data.razaoSocial2}</td>
                  <td>${data.tipo}</td>
                  <td>${data.mtrRef}</td>
                  <td>${data.litros}</td>
                  <td>${data.toneladas}</td>
                </tr>
              `
              )
              .join("");

            if (textOutput) {
              textOutput.innerHTML = `
                    <button id="copyButton"><i class="fas fa-copy"></i> Copiar</button>
                    <div class="table-container">
                      <table>
                        <thead>
                          <tr>
                            <th>DATA</th>
                            <th>MTR</th>
                            <th>TRANSPORTADOR</th>
                            <th>DESTINADOR</th>
                            <th>TIPO</th>
                            <th>TICKET</th>
                            <th>LITROS</th>
                            <th>TONELADAS</th>
                          </tr>
                        </thead>
                        <tbody>
                          ${tableRows}
                        </tbody>
                      </table>
                    </div>
                  `;
            }

            const copyButton = document.getElementById("copyButton");
            if (copyButton) {
              copyButton.addEventListener("click", () => {
                const tableRowsToCopy = document.querySelectorAll(
                  "#textOutput table tbody tr"
                );
                if (tableRowsToCopy.length > 0) {
                  const copyText = Array.from(tableRowsToCopy)
                    .map((row) => {
                      return Array.from(row.cells)
                        .map((cell) => cell.textContent)
                        .join("\t");
                    })
                    .join("\n");

                  if (copyToClipboard(copyText)) {
                    showAlertModal(
                      "Dados copiados para a área de transferência!",
                      "success"
                    );
                  } else {
                    showAlertModal("Erro ao copiar os dados.", "error");
                  }
                } else {
                  showAlertModal("Nenhum dado para copiar.", "no_data");
                }
              });
            }
          } else {
            if (textOutput) textOutput.innerHTML = ""; // Ensures table is not rendered
          }

          // --- Final Feedback Message Logic ---
          let feedbackMessageParts = [];
          let feedbackType = "no_data"; // Default: no valid data found
          // Determine total number of items initially dropped/selected for accurate messages
          let totalInitialItemsConsidered = 0;
          if (source instanceof FileList) {
            totalInitialItemsConsidered = source.length;
          } else if (source instanceof DataTransfer) {
            totalInitialItemsConsidered = source.items.length;
          }

          if (newUniqueDataCount > 0) {
            feedbackMessageParts.push(
              `${newUniqueDataCount} novo(s) MTR(s) extraído(s) e salvo(s).`
            );
            feedbackType = "success";
          }

          if (existingDuplicatesCount > 0) {
            feedbackMessageParts.push(
              `${existingDuplicatesCount} MTR(s) existente(s) ignorado(s).`
            );
            if (feedbackType === "success") {
              // If there were new data, it's a partial success
              feedbackType = "exists";
            } else {
              // If only duplicates, it's an "existing" state
              feedbackType = "exists";
            }
          }

          if (noMtrDataCount > 0) {
            feedbackMessageParts.push(
              `${noMtrDataCount} PDF(s) sem dados MTR válidos.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "no_data"; // Only this type of problem
            }
          }

          if (multiPageCount > 0) {
            feedbackMessageParts.push(
              `${multiPageCount} PDF(s) com múltiplas páginas ignorado(s).`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "no_data";
            }
          }

          if (nonPdfCount > 0) {
            feedbackMessageParts.push(
              `${nonPdfCount} arquivo(s) não PDF ignorado(s).`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "no_data";
            }
          }

          if (otherErrorCount > 0) {
            feedbackMessageParts.push(
              `${otherErrorCount} arquivo(s) com outros erros. (Consulte o console para detalhes)`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "error"; // More critical error type
            }
          }

          let finalMessage = "";
          if (feedbackMessageParts.length > 0) {
            finalMessage = feedbackMessageParts.join(" ");
          } else {
            // If no files were processed, show a general message based on whether anything was dropped
            if (totalInitialItemsConsidered > 0) {
              finalMessage =
                "Nenhum dado válido de MTR foi encontrado nos arquivos processados ou selecionados.";
              feedbackType = "no_data";
            } else {
              finalMessage = "Nenhum arquivo foi selecionado ou solto.";
              feedbackType = "no_data";
            }
          }

          showAlertModal(finalMessage, feedbackType);

          updateHistoryButtonVisibility();
        }

        // Função para atualizar a visibilidade do botão de histórico
        function updateHistoryButtonVisibility() {
          const historyButton = document.getElementById("historyButton");
          const storedData = JSON.parse(
            localStorage.getItem("residuosData") || "[]"
          );
          if (historyButton) {
            if (storedData.length > 0) {
              historyButton.style.display = "inline-block";
            } else {
              historyButton.style.display = "none";
            }
          }
        }

        // Adiciona listener para a imagem do rodapé
        const footerImage = document.getElementById("footerImage");
        if (footerImage) {
          footerImage.addEventListener("click", () =>
            swapFooterImage(footerImage)
          );
        }

        // --- Funcionalidade de Drag and Drop (Atualizada para o body) ---
        const bodyElement = document.body;
        const dragDropOverlay = document.getElementById("dragDropOverlay");

        // Contador para controlar entradas e saídas do drag (para evitar flicker)
        let dragCounter = 0;

        bodyElement.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dragCounter++;
          if (dragCounter === 1) {
            // Só ativa quando entra pela primeira vez
            bodyElement.classList.add("blur-active");
            dragDropOverlay.classList.add("active");
          }
        });

        bodyElement.addEventListener("dragover", (e) => {
          e.preventDefault(); // Necessário para permitir o drop
          e.dataTransfer.dropEffect = "copy"; // Indica que os dados serão copiados
        });

        bodyElement.addEventListener("dragleave", (e) => {
          // Verifica se o mouse saiu completamente da janela ou de um elemento filho
          // O target.tagName é o elemento de onde o dragleave aconteceu.
          // relacionados target é o elemento para onde o mouse está indo.
          // Se relatedTarget for null (significa que saiu da janela) ou fora de body.
          // Isso evita que o efeito seja desativado ao passar sobre elementos internos.
          dragCounter--;
          if (dragCounter === 0) {
            bodyElement.classList.remove("blur-active");
            dragDropOverlay.classList.remove("active");
          }
        });

        bodyElement.addEventListener("drop", async (e) => {
          e.preventDefault();
          dragCounter = 0; // Reseta o contador
          bodyElement.classList.remove("blur-active");
          dragDropOverlay.classList.remove("active");

          // Passar o objeto DataTransfer completo para handleFiles
          await handleFiles(e.dataTransfer);
        });
        // --- Fim da Funcionalidade de Drag and Drop ---

        // Adiciona listener para o input de arquivo (botão "Selecionar PDFs")
        const pdfInput = document.getElementById("pdfInput");
        if (pdfInput) {
          pdfInput.addEventListener("change", async (e) => {
            await handleFiles(e.target.files);
            e.target.value = ""; // Limpa o input para permitir selecionar os mesmos arquivos novamente
          });
        }

        // Chamada inicial para garantir que o botão esteja no estado correto ao carregar a página
        updateHistoryButtonVisibility();
      }); // Fechamento do DOMContentLoaded
    </script>
  </body>
</html>
