<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relatório de Resíduos Gerados</title>
    <!-- Metadados para SEO e Descrição da Página -->
    <meta
      name="description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta name="author" content="Jhon Randler" />
    <meta
      name="keywords"
      content="gestão de resíduos, relatório de resíduos, PDF, extração de dados, MTR, histórico de resíduos, ferramenta gratuita"
    />

    <!-- Open Graph Metadados para Redes Sociais (Facebook, WhatsApp, LinkedIn) -->
    <meta property="og:title" content="Relatório de Resíduos Gerados" />
    <meta
      property="og:description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://jhonnierandler.github.io/relatorio-de-residuos"
    />
    <!-- IMPORTANTE: Usar URL absoluta para a imagem para funcionar no WhatsApp e outras plataformas -->
    <!-- Ajustado para o tamanho real da imagem (408x408) -->
    <meta
      property="og:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta property="og:image:width" content="408" />
    <meta property="og:image:height" content="408" />
    <meta property="og:locale" content="pt_BR" />

    <!-- Twitter Card Metadados -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Relatório de Resíduos Gerados" />
    <meta
      name="twitter:description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta
      name="twitter:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta name="twitter:creator" content="@JhonnieRandler" />
    <!-- Altere @SeuHandleTwitter para o seu handle do Twitter, se tiver um -->

    <link rel="icon" type="image/png" href="footer.png" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- Link para o CSS centralizado -->
    <link rel="stylesheet" href="style.css" />
    <!-- Preload das imagens para carregamento mais rápido -->
    <link rel="preload" as="image" href="doubt.png" />
    <link rel="preload" as="image" href="footer.png" />
    <link rel="preload" as="image" href="blink.png" />
    <link rel="preload" as="image" href="like.png" />
    <link rel="preload" as="image" href="point.png" />
    <link rel="preload" as="image" href="sure.png" />
    <!-- Preload do áudio -->
    <link rel="preload" as="audio" href="blink.mp3" />
    <style>
      /* Estilos específicos da página inicial */
      body.blur-active > *:not(#dragDropOverlay) {
        filter: blur(5px);
        pointer-events: none;
      }
      .input-container {
        display: flex;
        justify-content: center;
        margin: 20px 0;
      }
      input[type="file"] {
        display: none;
      }
      .custom-file-upload {
        display: inline-block;
        padding: 12px 20px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      .custom-file-upload:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      #textOutput {
        margin-top: 20px;
      }
      #progressIndicator {
        margin-top: 10px;
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        min-height: 3em;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #progressIndicator span {
        display: block;
      }
      .history-button {
        margin: 10px 0;
        padding: 10px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      .history-button:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      #error,
      #messageBox {
        color: red;
        background-color: #ffe0e0;
        border: 1px solid red;
        padding: 10px;
        margin-top: 10px;
        border-radius: 8px;
        display: none;
      }
      #messageBox.success {
        color: green;
        background-color: #e0ffe0;
        border-color: green;
      }

      /* Drag and Drop Overlay styles */
      #dragDropOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg-transparent);
        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        padding: 20px;
      }
      #dragDropOverlay.active {
        opacity: 1;
        pointer-events: all;
      }
      #dragDropArea {
        border: 12px dashed var(--overlay-border-color);
        border-radius: 25px;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: border-color 0.3s ease;
      }
      #dragDropOverlay p {
        color: var(--drag-overlay-text);
        font-size: 3.5em;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        padding: 0;
        margin: 0;
        text-align: center;
      }
      /* Estilo específico para o botão de cancelar no modal de confirmação */
      #folderModalCancelBtn {
        background-color: #f44336;
      }
      #folderModalCancelBtn:hover {
        background-color: #d32f2f;
      }

      /* Media queries específicas da página inicial */
      @media screen and (max-width: 600px) {
        .custom-file-upload {
          padding: 10px 16px;
          font-size: 14px;
        }
        #dragDropOverlay p {
          font-size: 2em;
        }
      }
    </style>
  </head>
  <body>
    <div id="dragDropOverlay">
      <div id="dragDropArea">
        <p>Solte o MTR em qualquer lugar</p>
      </div>
    </div>

    <main id="mainContent">
      <div class="header-controls">
        <h1>Relatório de Resíduos Gerados</h1>
        <button id="themeToggle" class="theme-toggle-button">
          <i class="fas fa-moon"></i>
        </button>
      </div>
      <div class="input-container">
        <label for="pdfInput" class="custom-file-upload">
          <i class="fas fa-upload"></i> Selecionar PDFs
        </label>
        <input type="file" id="pdfInput" accept="application/pdf" multiple />
      </div>
      <button
        class="history-button"
        id="historyButton"
        onclick="window.location.href='historico/'"
      >
        <i class="fas fa-history"></i> Histórico
      </button>
      <div id="textOutput"></div>
      <div id="progressIndicator"></div>
      <!-- Novo elemento para o indicador de progresso -->
      <div id="error"></div>
      <div id="messageBox"></div>
      <!-- Adicionado para mensagens de sucesso/erro -->
    </main>
    <footer>
      <img id="footerImage" src="footer.png" alt="Image of a footer" />
      <p>
        Este site foi desenvolvido para facilitar a gestão de resíduos gerados,
        oferecendo uma ferramenta prática e acessível. É livre para uso por
        todos!
      </p>
      <!-- Elemento de áudio para o som de blink -->
      <audio id="blinkAudio" preload="auto">
        <source src="blink.mp3" type="audio/mpeg" />
        Seu navegador não suporta o elemento de áudio.
      </audio>
    </footer>

    <!-- Modal de Alerta Customizado (para erros e mensagens gerais) -->
    <div id="customAlertModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="alertModalImage"
          src=""
          alt="Ícone de Status"
          class="modal-image"
        />
        <p id="alertMessage"></p>
        <div class="modal-buttons">
          <button id="alertOkBtn">OK</button>
        </div>
      </div>
    </div>

    <!-- Novo Modal de Confirmação para Pastas -->
    <div id="folderConfirmModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="folderConfirmModalImage"
          src="point.png"
          alt="Ícone de Aviso"
          class="modal-image"
        />
        <p id="folderModalMessage"></p>
        <div class="modal-buttons">
          <button id="folderModalConfirmBtn">Sim</button>
          <button id="folderModalCancelBtn">Não</button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      // Configura o worker do PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

      // Variáveis globais para ordenação
      let currentTableData = []; // Stores the data currently displayed in the table
      let currentSortColumn = null;
      let currentSortDirection = "asc"; // 'asc' for ascending, 'desc' for descending

      // Mapeamento de nomes de colunas para chaves de dados
      const columnKeys = {
        DATA: "dataEmissao",
        MTR: "mtrFormatted",
        TRANSPORTADOR: "razaoSocial1",
        DESTINADOR: "razaoSocial2",
        TIPO: "tipo",
        TICKET: "mtrRef",
        LITROS: "litros",
        TONELADAS: "toneladas",
      };

      // Função para alternar o tema
      function toggleTheme() {
        const htmlElement = document.documentElement;
        const currentTheme = htmlElement.getAttribute("data-theme");
        const themeToggleBtn = document.getElementById("themeToggle");

        if (currentTheme === "dark") {
          htmlElement.removeAttribute("data-theme");
          localStorage.setItem("theme", "light");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        } else {
          htmlElement.setAttribute("data-theme", "dark");
          localStorage.setItem("theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        }
      }

      // Função para aplicar o tema salvo
      function applySavedTheme() {
        const savedTheme = localStorage.getItem("theme");
        const htmlElement = document.documentElement;
        const themeToggleBtn = document.getElementById("themeToggle");

        if (savedTheme === "dark") {
          htmlElement.setAttribute("data-theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        } else {
          htmlElement.removeAttribute("data-theme");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        }
      }

      // Envolve todo o código principal em um listener DOMContentLoaded
      document.addEventListener("DOMContentLoaded", () => {
        applySavedTheme(); // Aplica o tema salvo ao carregar a página

        const themeToggleBtn = document.getElementById("themeToggle");
        if (themeToggleBtn) {
          themeToggleBtn.addEventListener("click", toggleTheme);
        }

        // Mapeamento de códigos IBAMA para tipos, ajustado para consistência
        const ibamaCodeToType = {
          191213: "NÃO RECICLÁVEL",
          150202: "CONTAMINADO",
          "030101": "MADEIRA",
          "030301": "MADEIRA",
          "030308": "PAPEL",
          200139: "PLÁSTICO",
          200108: "ORGÂNICO",
          170503: "SOLO CONTAMINADO",
          170407: "SUCATA FERROSA",
          190899: "EFLUENTE SANITÁRIO",
          130201: "ÓLEO QUEIMADO",
          130507: "ÁGUA E ÓLEO",
        };
        const rccCodes = [
          "170201",
          "170202",
          "170203",
          "170401",
          "170402",
          "170403",
          "170404",
          "170405",
          "170406",
          "170411",
          "170412",
          "170413",
          "170802",
        ];

        // Função para exibir modais de alerta com imagem (para erros e mensagens gerais)
        function showAlertModal(message, type) {
          // type: 'success', 'exists', 'no_data', 'error'
          const modal = document.getElementById("customAlertModal");
          const alertMessage = document.getElementById("alertMessage");
          const alertModalImage = document.getElementById("alertModalImage");
          const okBtn = document.getElementById("alertOkBtn");

          if (alertMessage) alertMessage.textContent = message;
          if (modal) modal.classList.remove("success", "error"); // Limpa classes anteriores para evitar conflitos

          let imagePath = "";
          if (type === "success") {
            imagePath = "like.png";
            if (okBtn) okBtn.style.backgroundColor = "#4CAF50"; // Verde para sucesso
          } else if (type === "exists") {
            imagePath = "point.png";
            if (okBtn) okBtn.style.backgroundColor = "#FFA000"; // Laranja para "já existente"
          } else if (type === "no_data" || type === "error") {
            imagePath = "doubt.png";
            if (okBtn) okBtn.style.backgroundColor = "#f44336"; // Vermelho para erro/falha
          }

          if (alertModalImage) {
            alertModalImage.src = imagePath;
            alertModalImage.style.display = "block";
          }

          // Use the 'active' class to control modal display
          if (modal) modal.classList.add("active"); // Shows the modal

          const handleOk = () => {
            closeAlertModal();
          };

          const handleKeyDown = (e) => {
            if (e.key === "Enter" || e.key === "Escape") {
              e.preventDefault(); // Prevents default behavior (e.g., submitting forms, closing browser search)
              handleOk();
            }
          };

          const closeAlertModal = () => {
            if (modal) modal.classList.remove("active"); // Hides the modal
            if (okBtn) okBtn.removeEventListener("click", handleOk);
            document.removeEventListener("keydown", handleKeyDown); // Remove keyboard listener
            if (alertModalImage) alertModalImage.style.display = "none"; // Oculta a imagem ao fechar
          };

          // Ensure listeners are added only once
          // Clone and replace to remove old listeners robustly
          const newOkBtn = okBtn.cloneNode(true);
          okBtn.parentNode.replaceChild(newOkBtn, okBtn);

          newOkBtn.addEventListener("click", handleOk);
          document.addEventListener("keydown", handleKeyDown); // Add keyboard listener
        }

        // Nova função para o modal de confirmação de pasta
        function showFolderConfirmModal(message) {
          return new Promise((resolve) => {
            const modal = document.getElementById("folderConfirmModal");
            const modalMessage = document.getElementById("folderModalMessage");
            const confirmModalImage = document.getElementById(
              "folderConfirmModalImage"
            );
            const confirmBtn = document.getElementById("folderModalConfirmBtn");
            const cancelBtn = document.getElementById("folderModalCancelBtn");

            if (modalMessage) modalMessage.textContent = message;
            if (confirmModalImage) {
              confirmModalImage.src = "point.png"; // Ícone de "ponto de atenção"
              confirmModalImage.style.display = "block";
            }
            // Use the 'active' class to control modal display
            if (modal) modal.classList.add("active"); // Shows the modal

            const handleConfirm = () => {
              resolve(true);
              closeFolderConfirmModal();
            };

            const handleCancel = () => {
              resolve(false);
              closeFolderConfirmModal();
            };

            const handleKeyDown = (e) => {
              if (e.key === "Enter") {
                e.preventDefault(); // Prevents default Enter behavior (e.g., submitting forms)
                handleConfirm();
              } else if (e.key === "Escape") {
                e.preventDefault(); // Prevents default Esc behavior
                handleCancel();
              }
            };

            const closeFolderConfirmModal = () => {
              if (modal) modal.classList.remove("active"); // Hides the modal
              if (confirmBtn)
                confirmBtn.removeEventListener("click", handleConfirm);
              if (cancelBtn)
                cancelBtn.removeEventListener("click", handleCancel);
              document.removeEventListener("keydown", handleKeyDown); // Remove keyboard listener
              if (confirmModalImage) confirmModalImage.style.display = "none"; // Oculta a imagem ao fechar
            };

            // Ensure listeners are added only once
            // Clone and replace to remove old listeners robustly
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            newConfirmBtn.addEventListener("click", handleConfirm);
            newCancelBtn.addEventListener("click", handleCancel);
            document.addEventListener("keydown", handleKeyDown); // Add keyboard listener
          });
        }

        // Função para extrair dados do texto (usada por processPdfFile)
        async function extractData(text) {
          const extracted = {};

          const dataEmissaoMatch = text.match(
            /Data\s*da\s*emissão:?\s*(\d{2}\/\d{2}\/\d{4})/i
          );
          extracted.dataEmissao = dataEmissaoMatch
            ? dataEmissaoMatch[1]
            : "Não encontrada";

          // Modificação: Ajusta a regex para capturar MTR nº/n° ou MTR sem número
          const mtrMatch = text.match(/MTR\s*n[ºo°]:?\s*(\d+)/i);
          extracted.mtr = mtrMatch ? mtrMatch[1] : "Não encontrado";
          extracted.mtrFormatted = mtrMatch
            ? `MTR nº: ${mtrMatch[1]}`
            : "Não encontrado";

          // CORREÇÃO AQUI: Torna o "Ticket " opcional e lida com "nº" ou "n°" e espaços
          const mtrRefMatch = text.match(
            /Referente\s*ao\s*(?:Ticket\s*)?(?:MTR|CCO)\s*(?:n[ºo°]\s*)?(\d+)/i
          );
          extracted.mtrRef = mtrRefMatch ? mtrRefMatch[1] : "N/A";

          const razaoInicialMatches = text.matchAll(
            /Raz[ãa]o\s*Social:?\s*([^:]+?)(?=\s*(?:Raz[ãa]o\s*Social|Telefone|Endereço|$))/gi
          );
          let razoesIniciais = Array.from(razaoInicialMatches, (match) =>
            match[1].trim().split("-")[0].trim()
          );

          const razaoDestinadorMatch = text.match(
            /Identificação\s*do\s*Destinador.*?Raz[ãa]o\s*Social:?\s*([^:]+?)(?=\s*(?:Estado|Município|$))/is
          );
          const razaoDestinador = razaoDestinadorMatch
            ? razaoDestinadorMatch[1].trim().split("-")[0].trim()
            : null;

          let razoesSociais = [...razoesIniciais];
          if (razaoDestinador) razoesSociais.push(razaoDestinador);
          razoesSociais = razoesSociais.filter(
            (razao) =>
              !razao
                .toUpperCase()
                .includes("CONSORCIO CONSTRUTOR FERROVIA LUCAS DO RIO VERDE")
          );

          extracted.razaoSocial1 =
            razoesSociais.length > 0 ? razoesSociais[0] : "Não encontrada";
          extracted.razaoSocial2 =
            razoesSociais.length > 1
              ? razoesSociais[1]
              : razoesSociais.length === 1
              ? razoesSociais[0]
              : "Não encontrada";

          const estadoFisicoMatch = text.match(/.*?(SÓLIDO|LÍQUIDO)\s*CLASSE/i);
          extracted.estadoFisico = estadoFisicoMatch
            ? estadoFisicoMatch[1]
            : "Não encontrado";

          const quantidadeMatch = text.match(/Qtde.*?(\d+,\d{4})/i);
          let quantidade = quantidadeMatch
            ? quantidadeMatch[1]
            : "Não encontrada";

          const unidadeMatch = text.match(/\s(KG|TON)\s/i);
          const unidade = unidadeMatch ? unidadeMatch[1].toUpperCase() : "";

          const ibamaMatch = text.match(
            /Código\s*IBAMA\s*e\s*Denominação.*?(\d{6}(?:\(*\))?)/is
          );
          const ibamaCode = ibamaMatch
            ? ibamaMatch[1].replace(/\(.*\)/, "").trim()
            : "Não encontrado";
          if (ibamaCode === "Não encontrado") {
            extracted.tipo = "Não encontrado";
          } else if (ibamaCodeToType[ibamaCode]) {
            extracted.tipo = ibamaCodeToType[ibamaCode];
          } else if (rccCodes.includes(ibamaCode)) {
            extracted.tipo = "RCC";
          } else {
            extracted.tipo = ibamaCode;
          }

          // Nova lógica: Se o tipo for "ÓLEO QUEIMADO", sempre use toneladas
          if (extracted.tipo === "ÓLEO QUEIMADO") {
            extracted.litros = "";
            extracted.toneladas = quantidade;
          } else {
            extracted.litros =
              extracted.estadoFisico === "LÍQUIDO" ? quantidade : "";
            extracted.toneladas =
              extracted.estadoFisico === "SÓLIDO" ? quantidade : "";
          }

          if (
            extracted.toneladas &&
            unidade === "KG" &&
            extracted.tipo === "RCC"
          ) {
            extracted.toneladas = (
              parseFloat(quantidade.replace(",", ".")) / 1000
            )
              .toFixed(4)
              .replace(".", ",");
          }

          return extracted;
        }

        // Função para processar um único arquivo PDF
        async function processPdfFile(file) {
          // Verifica o tipo de arquivo antes de carregar
          if (file.type !== "application/pdf") {
            throw new Error("not-pdf");
          }

          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          if (pdf.numPages > 1) {
            throw new Error("multi-page-pdf"); // Erro customizado para PDFs com mais de uma página
          }

          let fullText = "";
          const page = await pdf.getPage(1); // Processa apenas a primeira página
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map((item) => item.str).join(" ");
          fullText += pageText + " ";

          return extractData(fullText); // Chama a função extractData
        }

        // Função para trocar a imagem do rodapé e reproduzir áudio
        function swapFooterImage(imgElement) {
          const originalSrc = imgElement.src;
          const blinkSrc = originalSrc.replace("footer.png", "blink.png");
          const audio = document.getElementById("blinkAudio");

          imgElement.src = blinkSrc;
          if (audio) {
            audio.currentTime = 0; // Reinicia o áudio se já estiver tocando
            audio
              .play()
              .catch((e) => console.error("Erro ao reproduzir áudio:", e));
          }
          setTimeout(() => {
            imgElement.src = originalSrc;
          }, 400); // Alterado para 400 milissegundos
        }

        // Função para copiar texto para a área de transferência
        function copyToClipboard(text) {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          // Torna o textarea invisível
          textarea.style.position = "fixed";
          textarea.style.top = "0";
          textarea.style.left = "0";
          textarea.style.width = "1em";
          textarea.style.height = "1em";
          textarea.style.border = "none";
          textarea.style.outline = "none";
          textarea.style.boxShadow = "none";
          textarea.style.background = "transparent";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            const successful = document.execCommand("copy");
            return successful;
          } catch (err) {
            console.error("Erro ao copiar:", err);
            return false;
          } finally {
            document.body.removeChild(textarea);
          }
        }

        /**
         * Reads entries from a directory recursively.
         * @param {FileSystemDirectoryEntry} directoryEntry The directory entry to read.
         * @param {Array<File>} filesArray The array to accumulate files.
         * @param {Set<string>} uniqueFileIdentifiers Set to track unique files by identifier.
         * @returns {Promise<void>} A promise that resolves when all files are read.
         */
        async function readDirectoryEntries(
          directoryEntry,
          filesArray,
          uniqueFileIdentifiers
        ) {
          return new Promise((resolve) => {
            const directoryReader = directoryEntry.createReader();
            let entries = [];

            const readBatch = () => {
              directoryReader.readEntries(async (batch) => {
                if (!batch.length) {
                  // No more entries, process them
                  for (const entry of entries) {
                    if (entry.isFile) {
                      const file = await new Promise((res) => entry.file(res));
                      if (file) {
                        // Use a more robust identifier for uniqueness
                        const identifier = `${file.name}-${file.size}-${file.lastModified}`;
                        if (!uniqueFileIdentifiers.has(identifier)) {
                          filesArray.push(file);
                          uniqueFileIdentifiers.add(identifier);
                        } else {
                          console.warn(
                            `[Deduplicação] Arquivo duplicado (dentro da pasta) ignorado na coleta: ${file.name}`
                          );
                        }
                      }
                    } else if (entry.isDirectory) {
                      // Recursively call for subdirectories
                      await readDirectoryEntries(
                        entry,
                        filesArray,
                        uniqueFileIdentifiers
                      );
                    }
                  }
                  resolve();
                } else {
                  entries = entries.concat(Array.from(batch));
                  readBatch(); // Continue reading the next batch
                }
              });
            };
            readBatch();
          });
        }

        /**
         * Renders the data in the table.
         * @param {Array<Object>} dataToRender The array of MTR objects to display.
         */
        function renderTable(dataToRender) {
          const textOutput = document.getElementById("textOutput");
          if (dataToRender.length === 0) {
            if (textOutput) textOutput.innerHTML = "";
            return;
          }

          let tableRows = dataToRender
            .map(
              (data, index) => `
                <tr>
                  <td>${index + 1}</td> <!-- Índice visual da linha -->
                  <td>${data.dataEmissao}</td>
                  <td>${data.mtrFormatted}</td>
                  <td>${data.razaoSocial1}</td>
                  <td>${data.razaoSocial2}</td>
                  <td>${data.tipo}</td>
                  <td>${data.mtrRef}</td>
                  <td>${data.litros}</td>
                  <td>${data.toneladas}</td>
                </tr>
              `
            )
            .join("");

          if (textOutput) {
            textOutput.innerHTML = `
                    <button id="copyButton"><i class="fas fa-copy"></i> Copiar</button>
                    <div class="table-container">
                      <table>
                        <thead>
                          <tr>
                            <th>Nº</th> <!-- Nova coluna para o índice visual -->
                            <th data-column="dataEmissao">DATA <span class="sort-arrow"></span></th>
                            <th data-column="mtrFormatted">MTR <span class="sort-arrow"></span></th>
                            <th data-column="razaoSocial1">TRANSPORTADOR <span class="sort-arrow"></span></th>
                            <th data-column="razaoSocial2">DESTINADOR <span class="sort-arrow"></span></th>
                            <th data-column="tipo">TIPO <span class="sort-arrow"></span></th>
                            <th data-column="mtrRef">TICKET <span class="sort-arrow"></span></th>
                            <th data-column="litros">LITROS <span class="sort-arrow"></span></th>
                            <th data-column="toneladas">TONELADAS <span class="sort-arrow"></span></th>
                          </tr>
                        </thead>
                        <tbody>
                          ${tableRows}
                        </tbody>
                      </table>
                    </div>
                `;
          }

          // Add sorting event listeners to headers (excluding the new Nº column)
          const headers = textOutput.querySelectorAll("th");
          headers.forEach((header) => {
            // Only add listener to sortable columns (those with data-column attribute)
            if (header.dataset.column) {
              header.addEventListener("click", () => {
                const column = header.dataset.column;
                sortTable(column);
              });
            }
          });

          // Update sort arrows
          updateSortArrows();

          const copyButton = document.getElementById("copyButton");
          if (copyButton) {
            copyButton.addEventListener("click", () => {
              const tableRowsToCopy = document.querySelectorAll(
                "#textOutput table tbody tr"
              );
              if (tableRowsToCopy.length > 0) {
                const copyText = Array.from(tableRowsToCopy)
                  .map((row) => {
                    // Mapeia as células da linha, começando da segunda célula (índice 1) para excluir o Nº
                    return Array.from(row.cells)
                      .slice(1) // Exclui a primeira célula (Nº)
                      .map((cell) => cell.textContent)
                      .join("\t");
                  })
                  .join("\n");

                if (copyToClipboard(copyText)) {
                  showAlertModal(
                    "Dados copiados para a área de transferência!",
                    "success"
                  );
                } else {
                  showAlertModal("Erro ao copiar os dados.", "error");
                }
              } else {
                showAlertModal("Nenhum dado para copiar.", "no_data");
              }
            });
          }
        }

        /**
         * Sorts the currentTableData based on the selected column.
         * @param {string} column The data key to sort by.
         */
        function sortTable(column) {
          // Determine sort direction
          if (currentSortColumn === column) {
            currentSortDirection =
              currentSortDirection === "asc" ? "desc" : "asc";
          } else {
            currentSortColumn = column;
            currentSortDirection = "asc";
          }

          currentTableData.sort((a, b) => {
            let valA = a[column];
            let valB = b[column];

            // Special handling for numeric values (litros, toneladas, MTR, Ticket)
            if (
              column === "litros" ||
              column === "toneladas" ||
              column === "mtrFormatted" ||
              column === "mtrRef"
            ) {
              // Remove "MTR nº: " prefix for MTR, and handle comma as decimal separator for numbers
              if (column === "mtrFormatted")
                valA = String(valA).replace("MTR nº: ", "");
              if (column === "mtrFormatted")
                valB = String(valB).replace("MTR nº: ", "");

              valA = parseFloat(String(valA).replace(",", ".") || 0);
              valB = parseFloat(String(valB).replace(",", ".") || 0);

              if (isNaN(valA)) valA = -Infinity; // Treat "Não encontrada" or "N/A" as smallest
              if (isNaN(valB)) valB = -Infinity;

              return currentSortDirection === "asc" ? valA - valB : valB - valA;
            }

            // Special handling for date (DD/MM/YYYY)
            if (column === "dataEmissao") {
              // Convert DD/MM/YYYY to ISO నేపథ్యంలో-MM-DD for correct comparison
              const dateA = valA.split("/").reverse().join("-");
              const dateB = valB.split("/").reverse().join("-");
              if (dateA < dateB) return currentSortDirection === "asc" ? -1 : 1;
              if (dateA > dateB) return currentSortDirection === "asc" ? 1 : -1;
              return 0;
            }

            // Default string comparison
            if (typeof valA === "string" && typeof valB === "string") {
              valA = valA.toLowerCase();
              valB = valB.toLowerCase();
              if (valA < valB) return currentSortDirection === "asc" ? -1 : 1;
              if (valA > valB) return currentSortDirection === "asc" ? 1 : -1;
            }
            return 0;
          });

          renderTable(currentTableData); // Re-render the table with sorted data
        }

        /**
         * Updates the sort arrows in the table headers.
         */
        function updateSortArrows() {
          const headers = document.querySelectorAll("#textOutput th");
          headers.forEach((header) => {
            let arrowSpan = header.querySelector(".sort-arrow");
            if (!arrowSpan) {
              // Create if it doesn't exist
              arrowSpan = document.createElement("span");
              arrowSpan.classList.add("sort-arrow");
              header.appendChild(arrowSpan);
            }
            arrowSpan.textContent = ""; // Clear previous arrow
            // Only add arrow to sortable columns
            if (header.dataset.column === currentSortColumn) {
              arrowSpan.textContent =
                currentSortDirection === "asc" ? " ↑" : " ↓";
            }
          });
        }

        // Function to handle files from input or drag-and-drop
        async function handleFiles(source) {
          const textOutput = document.getElementById("textOutput");
          const errorDiv = document.getElementById("error");
          const messageBox = document.getElementById("messageBox");
          const progressIndicator =
            document.getElementById("progressIndicator");

          // Clear previous messages and indicators
          if (textOutput) textOutput.innerHTML = "";
          if (errorDiv) errorDiv.style.display = "none";
          if (messageBox) {
            messageBox.style.display = "none";
            messageBox.classList.remove(
              "success",
              "error",
              "exists",
              "no_data"
            );
          }
          // Display initial loading message
          if (progressIndicator) {
            progressIndicator.innerHTML = `<span>Carregando arquivos para processamento...</span><span>(Isso pode levar alguns instantes para pastas grandes)</span>`;
          }

          let filesToProcess = [];
          const uniqueFileIdentifiers = new Set(); // For deduplication

          // Function to add a file to filesToProcess if it's unique
          function addFileIfUnique(file) {
            if (!file || !(file instanceof File)) {
              console.warn(
                "[Coleta] Objeto inválido tentado adicionar à fila de processamento (não é um File):",
                file
              );
              return;
            }

            // Ensure file.size and file.lastModified are valid numbers
            const fileSize = typeof file.size === "number" ? file.size : 0;
            const fileLastModified =
              typeof file.lastModified === "number" ? file.lastModified : 0;

            const identifier = `${file.name}-${fileSize}-${fileLastModified}`;

            if (!uniqueFileIdentifiers.has(identifier)) {
              filesToProcess.push(file);
              uniqueFileIdentifiers.add(identifier);
              console.log(
                `[Coleta - Adicionado] Arquivo: ${file.name} (ID: ${identifier}). Total na fila: ${filesToProcess.length}`
              ); // New log
            } else {
              console.warn(
                `[Deduplicação - Ignorado] Arquivo: ${file.name} (ID: ${identifier}) já presente na lista.`
              ); // Enhanced log
            }
          }

          // Scenario 1: From <input type="file"> (FileList)
          if (source instanceof FileList) {
            console.log(
              `[Coleta] Fonte: FileList (do input type=file). Total de arquivos na seleção: ${source.length}`
            ); // New log
            Array.from(source).forEach((file) => addFileIfUnique(file));
          }
          // Scenario 2: From Drag and Drop (DataTransfer object)
          else if (source instanceof DataTransfer) {
            console.log("[Coleta] Fonte: DataTransfer (do arrastar e soltar).");

            // --- PRIORITY: Process files from DataTransfer.files first ---
            // This is generally the most reliable way to get actual File objects from a drag,
            // especially for multiple individual files.
            if (source.files && source.files.length > 0) {
              console.log(
                `[Coleta] Tentando coletar ${source.files.length} arquivos diretamente de DataTransfer.files.`
              );
              Array.from(source.files).forEach((file) => {
                addFileIfUnique(file);
              });
              console.log(
                `[Coleta] Arquivos coletados de DataTransfer.files: ${filesToProcess.length} (após deduplicação inicial).`
              );
            }

            // --- SECONDARY: Iterate DataTransfer.items to handle directory entries ---
            // This is primarily for detecting and processing dropped folders, as DataTransfer.files
            // flattens the hierarchy and doesn't explicitly mark directories.
            if (source.items) {
              console.log(
                `[Coleta] Verificando ${source.items.length} itens de DataTransfer.items para pastas.`
              );
              for (const item of Array.from(source.items)) {
                if (item.webkitGetAsEntry) {
                  // Check for webkitGetAsEntry support
                  const entry = item.webkitGetAsEntry();
                  if (entry) {
                    // Ensure entry is not null
                    if (entry.isDirectory) {
                      console.log(`[Coleta] Pasta detectada: "${entry.name}"`);
                      const confirmed = await showFolderConfirmModal(
                        `Uma pasta foi detectada: "${entry.name}". Deseja processar os arquivos MTR dentro dela?`
                      );
                      if (confirmed) {
                        await readDirectoryEntries(
                          entry,
                          filesToProcess,
                          uniqueFileIdentifiers
                        );
                        console.log(
                          `[Coleta] Arquivos adicionados da pasta "${entry.name}". Total atual: ${filesToProcess.length}`
                        );
                      } else {
                        console.log(
                          `[Coleta] Processamento da pasta "${entry.name}" cancelado pelo usuário.`
                        );
                      }
                    }
                    // If it's entry.isFile, it should have already been caught by DataTransfer.files above.
                    // We rely on addFileIfUnique to prevent duplicates if it happens to be processed again.
                  } else {
                    console.warn(
                      `[Coleta] webkitGetAsEntry retornou nulo para item do tipo: ${
                        item.kind || "desconhecido"
                      } - ${item.type || "desconhecido"}.`
                    );
                  }
                } else if (item.kind === "file" && item.getAsFile) {
                  // Fallback for browsers that don't support webkitGetAsEntry well for files,
                  // or for simple file drops where getAsFile() might be the primary method.
                  try {
                    const file = item.getAsFile();
                    if (file) {
                      addFileIfUnique(file);
                      console.log(
                        `[Coleta] Arquivo via item.getAsFile (fallback): ${file.name}`
                      );
                    } else {
                      console.warn(
                        `[Coleta] item.getAsFile: Objeto File não obtido para item ${
                          item.type || "desconhecido"
                        }.`
                      );
                    }
                  } catch (e) {
                    console.error(
                      `[Coleta] Erro ao obter arquivo via item.getAsFile(): ${e}`
                    );
                  }
                }
              }
            } else {
              console.warn(
                "[Coleta] DataTransfer.items não disponível ou vazio."
              );
            }
          } else {
            showAlertModal(
              "Nenhum arquivo ou pasta foi selecionado ou solto.",
              "no_data"
            );
            if (progressIndicator) progressIndicator.innerHTML = "";
            return;
          }

          // At this point, filesToProcess should contain only unique File objects, ready for PDF processing.

          if (filesToProcess.length === 0) {
            showAlertModal(
              "Nenhum arquivo PDF válido encontrado para processar na seleção (ou o processamento das pastas foi cancelado/estavam vazias/não continham PDFs válidos).",
              "no_data"
            );
            if (progressIndicator) progressIndicator.innerHTML = "";
            return;
          }

          console.log(
            `[Coleta Final] Total de arquivos PDF únicos a serem processados: ${filesToProcess.length}`
          );

          let extractedDataResults = []; // Stores results of all PDF processing attempts
          let nonPdfCount = 0;
          let multiPageCount = 0;
          let noMtrDataCount = 0; // PDFs that were valid but had no MTR data
          let otherErrorCount = 0; // For errors during PDF loading/parsing
          // These counts will now refer to the final outcomes based on MTR data, not just file types
          let newUniqueDataCount = 0; // MTRs that are truly new and added to localStorage
          let existingDuplicatesInLocalStorageCount = 0; // MTRs already present in localStorage
          let duplicatesInCurrentSelectionCount = 0; // MTRs duplicated within the current drag/select operation

          // Update progress indicator before starting the loop
          if (progressIndicator) {
            progressIndicator.innerHTML = `<span>Processando 0 de ${filesToProcess.length} arquivos...</span><span>(Aguarde...)</span>`;
          }

          for (const file of filesToProcess) {
            if (progressIndicator) {
              // Update progress for each file iteration
              progressIndicator.innerHTML = `<span>Processando arquivo ${
                extractedDataResults.length + 1
              } de ${filesToProcess.length}...</span><span>(${
                file.name
              })</span>`;
            }
            console.log(
              `[Processamento] Iniciando processamento de: ${file.name}`
            );

            try {
              const pdfData = await processPdfFile(file);
              extractedDataResults.push({
                ...pdfData,
                _processedSuccessfully: true,
                _fileName: file.name,
              });
              console.log(
                `[Processamento] Sucesso na extração para ${file.name}.`
              );
            } catch (error) {
              if (error.message === "multi-page-pdf") {
                multiPageCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "multi-page",
                  _fileName: file.name,
                });
                console.warn(
                  `[Processamento] Arquivo ignorado (mais de uma página): ${file.name}`
                );
              } else if (error.message === "not-pdf") {
                nonPdfCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "not-pdf",
                  _fileName: file.name,
                });
                console.warn(
                  `[Processamento] Arquivo ignorado (não é PDF): ${file.name}`
                );
              } else {
                otherErrorCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "other-error",
                  _fileName: file.name,
                  _errorMessage: error.message,
                });
                console.error(
                  `[Processamento] Erro ao processar arquivo ${file.name}:`,
                  error
                );
              }
            }
          }

          // Clear progress indicator after processing
          if (progressIndicator) {
            progressIndicator.innerHTML = "";
          }

          let storedData = JSON.parse(
            localStorage.getItem("residuosData") || "[]"
          );
          const tempDataForTableDisplay = []; // This will only contain unique, new MTRs for the current display
          const mtrsAddedToTempDisplay = new Set(); // To prevent duplicates in current table display

          console.log(
            `[Verificação Duplicatas] Iniciando verificação de duplicatas. Total atual em localStorage: ${storedData.length}`
          );
          extractedDataResults.forEach((item) => {
            if (item._processedSuccessfully) {
              const { _processedSuccessfully, _fileName, ...cleanItem } = item;

              // Check if extracted data meets criteria for a "valid MTR"
              if (
                cleanItem.dataEmissao !== "Não encontrada" &&
                cleanItem.mtrFormatted !== "Não encontrado" &&
                cleanItem.razaoSocial1 !== "Não encontrada" &&
                cleanItem.razaoSocial2 !== "Não encontrada" &&
                cleanItem.tipo !== "Não encontrado"
              ) {
                const currentMtrIdentifier = `${cleanItem.mtrFormatted}-${cleanItem.dataEmissao}`;

                const isDuplicateInLocalStorage = storedData.some(
                  (existingItem) =>
                    `${existingItem.mtrFormatted}-${existingItem.dataEmissao}` ===
                    currentMtrIdentifier
                );

                const isDuplicateInCurrentDisplay =
                  mtrsAddedToTempDisplay.has(currentMtrIdentifier);

                if (
                  !isDuplicateInLocalStorage &&
                  !isDuplicateInCurrentDisplay
                ) {
                  storedData.push(cleanItem); // Add to main list in localStorage
                  newUniqueDataCount++;
                  tempDataForTableDisplay.push(cleanItem); // Add for current table display
                  mtrsAddedToTempDisplay.add(currentMtrIdentifier); // Mark as added to current display
                  console.log(
                    `[Verificação Duplicatas] NOVO: MTR: ${cleanItem.mtrFormatted} (Data: ${cleanItem.dataEmissao}) - Arquivo: ${_fileName} adicionado ao histórico e exibição.`
                  );
                } else if (isDuplicateInLocalStorage) {
                  existingDuplicatesInLocalStorageCount++;
                  console.log(
                    `[Verificação Duplicatas] EXISTENTE (no histórico): MTR: ${cleanItem.mtrFormatted} (Data: ${cleanItem.dataEmissao}) - Arquivo: ${_fileName} já existe no histórico.`
                  );
                  // We do NOT add to tempDataForTableDisplay here, as per requirement
                } else if (isDuplicateInCurrentDisplay) {
                  duplicatesInCurrentSelectionCount++;
                  console.warn(
                    `[Verificação Duplicatas] DUPLICADO (na seleção atual): MTR: ${cleanItem.mtrFormatted} (Data: ${cleanItem.dataEmissao}) - Arquivo: ${_fileName} é duplicado na seleção atual e não será exibido na tabela.`
                  );
                  // We do NOT add to tempDataForTableDisplay here, as per requirement
                }
              } else {
                noMtrDataCount++; // Count PDFs that did not yield valid MTR data
                console.warn(
                  `[Verificação Duplicatas] PDF sem dados MTR válidos (MTR não extraído) para arquivo: ${_fileName}`
                );
              }
            } else {
              // Log details for files that failed initial PDF processing (e.g., non-PDF, multi-page)
              console.warn(
                `[Verificação Duplicatas] Arquivo não processado com sucesso: ${
                  item._fileName || "Nome de arquivo desconhecido"
                } - Razão: ${item._reason || "Desconhecida"}`
              );
            }
          });

          // Save updated data to localStorage
          localStorage.setItem("residuosData", JSON.stringify(storedData));
          console.log(
            `[Verificação Duplicatas] Histórico final salvo. Total de MTRs no histórico: ${storedData.length}`
          );

          // Set currentTableData for sorting
          currentTableData = tempDataForTableDisplay;

          // Render table ONLY if there is data to display in this execution
          renderTable(currentTableData);

          // --- Final Feedback Message Logic ---
          let feedbackMessageParts = [];
          let feedbackType = "no_data"; // Default: no valid data found

          // Helper function for pluralization
          const pluralize = (count, singular, plural) =>
            count === 1 ? singular : plural;

          // Base message about total files attempted to be processed
          let totalFilesAttemptedForProcessing = filesToProcess.length; // Number of unique file objects processed

          if (newUniqueDataCount > 0) {
            feedbackMessageParts.push(
              `${newUniqueDataCount} ${pluralize(
                newUniqueDataCount,
                "novo",
                "novos"
              )} MTR${pluralize(newUniqueDataCount, "", "s")} ${pluralize(
                newUniqueDataCount,
                "extraído",
                "extraídos"
              )} e ${pluralize(newUniqueDataCount, "salvo", "salvos")}.`
            );
            feedbackType = "success";
          }

          if (duplicatesInCurrentSelectionCount > 0) {
            feedbackMessageParts.push(
              `${duplicatesInCurrentSelectionCount} MTR${pluralize(
                duplicatesInCurrentSelectionCount,
                "",
                "s"
              )} ${pluralize(
                duplicatesInCurrentSelectionCount,
                "duplicado",
                "duplicados"
              )} na seleção atual (não ${pluralize(
                duplicatesInCurrentSelectionCount,
                "exibido",
                "exibidos"
              )}).`
            );
            if (feedbackType === "success") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "exists";
            }
          }

          if (existingDuplicatesInLocalStorageCount > 0) {
            feedbackMessageParts.push(
              `${existingDuplicatesInLocalStorageCount} MTR${pluralize(
                existingDuplicatesInLocalStorageCount,
                "",
                "s"
              )} já ${pluralize(
                existingDuplicatesInLocalStorageCount,
                "existente",
                "existentes"
              )} no histórico (não ${pluralize(
                existingDuplicatesInLocalStorageCount,
                "salvo",
                "salvos"
              )}).`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "exists";
            }
          }

          if (noMtrDataCount > 0) {
            feedbackMessageParts.push(
              `${noMtrDataCount} PDF${pluralize(
                noMtrDataCount,
                "",
                "s"
              )} sem ${pluralize(
                noMtrDataCount,
                "dado",
                "dados"
              )} MTR ${pluralize(noMtrDataCount, "válido", "válidos")}.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "no_data"; // Only this type of problem
            }
          }

          if (multiPageCount > 0) {
            feedbackMessageParts.push(
              `${multiPageCount} PDF${pluralize(
                multiPageCount,
                "",
                "s"
              )} com ${pluralize(
                multiPageCount,
                "múltipla",
                "múltiplas"
              )} página${pluralize(multiPageCount, "", "s")} ${pluralize(
                multiPageCount,
                "ignorado",
                "ignorados"
              )}.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "no_data";
            }
          }

          if (nonPdfCount > 0) {
            feedbackMessageParts.push(
              `${nonPdfCount} ${pluralize(
                nonPdfCount,
                "arquivo",
                "arquivos"
              )} não PDF ${pluralize(nonPdfCount, "ignorado", "ignorados")}.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "no_data";
            }
          }

          if (otherErrorCount > 0) {
            feedbackMessageParts.push(
              `${otherErrorCount} ${pluralize(
                otherErrorCount,
                "arquivo",
                "arquivos"
              )} com ${pluralize(
                otherErrorCount,
                "outro",
                "outros"
              )} ${pluralize(
                otherErrorCount,
                "erro",
                "erros"
              )}. (Consulte o console para detalhes)`
            );
            if (
              feedbackType === "success" ||
              feedbackType === "exists" ||
              feedbackType === "no_data"
            ) {
              feedbackType = "error"; // Elevate to error if there are parsing errors
            } else {
              feedbackType = "error";
            }
          }

          let finalMessage = "";
          if (feedbackMessageParts.length > 0) {
            finalMessage =
              `Processamento de ${totalFilesAttemptedForProcessing} ${pluralize(
                totalFilesAttemptedForProcessing,
                "arquivo",
                "arquivos"
              )} concluído: ` + feedbackMessageParts.join(" ");
          } else {
            if (totalFilesAttemptedForProcessing > 0) {
              finalMessage = `Processamento de ${totalFilesAttemptedForProcessing} ${pluralize(
                totalFilesAttemptedForProcessing,
                "arquivo",
                "arquivos"
              )} concluído: Nenhum dado válido de MTR foi encontrado.`;
              feedbackType = "no_data";
            } else {
              finalMessage = "Nenhum arquivo foi selecionado ou solto.";
              feedbackType = "no_data";
            }
          }

          showAlertModal(finalMessage, feedbackType);

          updateHistoryButtonVisibility();
        }

        // Função para atualizar a visibilidade do botão de histórico
        function updateHistoryButtonVisibility() {
          const historyButton = document.getElementById("historyButton");
          const storedData = JSON.parse(
            localStorage.getItem("residuosData") || "[]"
          );
          if (historyButton) {
            if (storedData.length > 0) {
              historyButton.style.display = "inline-block";
            } else {
              historyButton.style.display = "none";
            }
          }
        }

        // Adiciona listener para a imagem do rodapé
        const footerImage = document.getElementById("footerImage");
        if (footerImage) {
          footerImage.addEventListener("click", () =>
            swapFooterImage(footerImage)
          );
        }

        // --- Funcionalidade de Drag and Drop (Atualizada para o body) ---
        const bodyElement = document.body;
        const dragDropOverlay = document.getElementById("dragDropOverlay");

        // Contador para controlar entradas e saídas do drag (para evitar flicker)
        let dragCounter = 0;

        bodyElement.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dragCounter++;
          if (dragCounter === 1) {
            // Só ativa quando entra pela primeira vez
            bodyElement.classList.add("blur-active");
            dragDropOverlay.classList.add("active");
          }
        });

        bodyElement.addEventListener("dragover", (e) => {
          e.preventDefault(); // Necessário para permitir o drop
          e.dataTransfer.dropEffect = "copy"; // Indica que os dados serão copiados
        });

        bodyElement.addEventListener("dragleave", (e) => {
          // Verifica se o mouse saiu completamente da janela ou de um elemento filho
          // O target.tagName é o elemento de onde o dragleave aconteceu.
          // relacionados target é o elemento para onde o mouse está indo.
          // Se relatedTarget for null (significa que saiu da janela) ou fora de body.
          // Isso evita que o efeito seja desativado ao passar sobre elementos internos.
          dragCounter--;
          if (dragCounter === 0) {
            bodyElement.classList.remove("blur-active");
            dragDropOverlay.classList.remove("active");
          }
        });

        bodyElement.addEventListener("drop", async (e) => {
          e.preventDefault();
          dragCounter = 0; // Reseta o contador
          bodyElement.classList.remove("blur-active");
          dragDropOverlay.classList.remove("active");

          // Passar o objeto DataTransfer completo para handleFiles
          await handleFiles(e.dataTransfer);
        });
        // --- Fim da Funcionalidade de Drag and Drop ---

        // Adiciona listener para o input de arquivo (botão "Selecionar PDFs")
        const pdfInput = document.getElementById("pdfInput");
        if (pdfInput) {
          pdfInput.addEventListener("change", async (e) => {
            await handleFiles(e.target.files);
            e.target.value = ""; // Limpa o input para permitir selecionar os mesmos arquivos novamente
          });
        }

        // Chamada inicial para garantir que o botão esteja no estado correto ao carregar a página
        updateHistoryButtonVisibility();
      }); // Fechamento do DOMContentLoaded
    </script>
  </body>
</html>
