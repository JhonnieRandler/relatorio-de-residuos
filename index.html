<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Relatório de Resíduos Gerados</title>
    <!-- Metadados para SEO e Descrição da Página -->
    <meta
      name="description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta name="author" content="Jhon Randler" />
    <meta
      name="keywords"
      content="gestão de resíduos, relatório de resíduos, PDF, extração de dados, MTR, histórico de resíduos, ferramenta gratuita"
    />

    <!-- Open Graph Metadados para Redes Sociais (Facebook, WhatsApp, LinkedIn) -->
    <meta property="og:title" content="Relatório de Resíduos Gerados" />
    <meta
      property="og:description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="https://jhonnierandler.github.io/relatorio-de-residuos"
    />
    <!-- IMPORTANTE: Usar URL absoluta para a imagem para funcionar no WhatsApp e outras plataformas -->
    <!-- Ajustado para o tamanho real da imagem (408x408) -->
    <meta
      property="og:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta property="og:image:width" content="408" />
    <meta property="og:image:height" content="408" />
    <meta property="og:locale" content="pt_BR" />

    <!-- Twitter Card Metadados -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Relatório de Resíduos Gerados" />
    <meta
      name="twitter:description"
      content="Ferramenta prática e gratuita para gestão de resíduos gerados, com extração de dados de PDFs e geração de relatórios."
    />
    <meta
      name="twitter:image"
      content="https://jhonnierandler.github.io/relatorio-de-residuos/footer.png"
    />
    <meta name="twitter:creator" content="@JhonnieRandler" />
    <!-- Altere @SeuHandleTwitter para o seu handle do Twitter, se tiver um -->

    <link rel="icon" type="image/png" href="footer.png" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <!-- Link para o CSS centralizado -->
    <link rel="stylesheet" href="style.css" />
    <!-- Preload das imagens para carregamento mais rápido -->
    <link rel="preload" as="image" href="doubt.png" />
    <link rel="preload" as="image" href="footer.png" />
    <link rel="preload" as="image" href="blink.png" />
    <link rel="preload" as="image" href="like.png" />
    <link rel="preload" as="image" href="point.png" />
    <link rel="preload" as="image" href="sure.png" />
    <!-- Preload do áudio -->
    <link rel="preload" as="audio" href="blink.mp3" />
    <style>
      /* Estilos específicos da página inicial */
      body.blur-active > *:not(#dragDropOverlay) {
        filter: blur(5px);
        pointer-events: none;
      }
      .input-container {
        display: flex;
        justify-content: center;
        margin: 20px 0;
      }
      input[type="file"] {
        display: none;
      }
      .custom-file-upload {
        display: inline-block;
        padding: 12px 20px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      .custom-file-upload:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      #textOutput {
        margin-top: 20px;
      }
      #progressIndicator {
        margin-top: 10px;
        font-size: 1.1em;
        font-weight: bold;
        color: var(--text-color);
        min-height: 3em;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }
      #progressIndicator span {
        display: block;
      }
      .history-button {
        margin: 10px 0;
        padding: 10px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        border: none;
        border-radius: 8px;
        box-shadow: 0 2px 4px var(--box-shadow-color);
        cursor: pointer;
        font-size: 16px;
        transition: background-color 0.3s, transform 0.2s, color 0.3s ease,
          box-shadow 0.3s ease;
      }
      .history-button:hover {
        background-color: var(--button-hover-bg-color);
        color: var(--button-hover-text-color);
        transform: translateY(-2px);
      }
      #error,
      #messageBox {
        color: red;
        background-color: #ffe0e0;
        border: 1px solid red;
        padding: 10px;
        margin-top: 10px;
        border-radius: 8px;
        display: none;
      }
      #messageBox.success {
        color: green;
        background-color: #e0ffe0;
        border-color: green;
      }

      /* Drag and Drop Overlay styles */
      #dragDropOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--overlay-bg-transparent);
        z-index: 999;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
        padding: 20px;
      }
      #dragDropOverlay.active {
        opacity: 1;
        pointer-events: all;
      }
      #dragDropArea {
        border: 12px dashed var(--overlay-border-color);
        border-radius: 25px;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: border-color 0.3s ease;
      }
      #dragDropOverlay p {
        color: var(--drag-overlay-text);
        font-size: 3.5em;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        padding: 0;
        margin: 0;
        text-align: center;
      }
      /* Estilo específico para o botão de cancelar no modal de confirmação */
      #folderModalCancelBtn,
      #bulkEditModalCancelBtn,
      #batchEditModalCancelBtn {
        background-color: #f44336;
      }
      #folderModalCancelBtn:hover,
      #bulkEditModalCancelBtn:hover,
      #batchEditModalCancelBtn:hover {
        background-color: #d32f2f;
      }

      /* Novo estilo para o botão de edição em lote */
      .action-button {
        display: none; /* Escondido por padrão, mostrado com JS */
      }
      .action-button.active {
        display: inline-block;
      }

      /* Estilo para a célula editável */
      .editable-table-input {
        width: 100%;
        box-sizing: border-box;
        padding: 4px;
        border: 1px solid var(--input-border-color);
        border-radius: 4px;
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
      }

      /* Estilo para o input e select do modal de edição em massa */
      .editable-input,
      .editable-select {
        width: 100%;
        box-sizing: border-box;
        padding: 8px; /* Ajustado para 8px para consistência com filter-input */
        border: 1px solid var(--input-border-color);
        border-radius: 8px; /* Ajustado para 8px para consistência com filter-input */
        background-color: var(--button-bg-color);
        color: var(--button-text-color);
        outline: none;
        margin-top: 10px; /* Adicionado margem superior */
      }

      /* Estilo para o checkbox da tabela (linhas individuais) */
      .row-checkbox {
        margin: 0;
        vertical-align: middle;
        width: 18px; /* Tamanho fixo */
        height: 18px; /* Tamanho fixo */
        appearance: none; /* Remove o estilo padrão do navegador */
        -webkit-appearance: none;
        -moz-appearance: none;
        border: 2px solid var(--input-border-color);
        border-radius: 4px;
        background-color: var(--button-bg-color);
        cursor: pointer;
        position: relative;
        display: inline-block; /* Para centralizar com text-align */
      }

      .row-checkbox:checked {
        background-color: var(
          --button-hover-bg-color
        ); /* Cor de fundo quando marcado */
        border-color: var(
          --button-hover-bg-color
        ); /* Cor da borda quando marcado */
      }

      .row-checkbox:checked::after {
        content: "\2713"; /* Sinal de 'check' */
        color: var(--button-hover-text-color); /* Cor do sinal de check */
        font-size: 14px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      /* Estilo para o checkbox de "selecionar todos" no cabeçalho */
      #selectAllCheckbox {
        margin: 0;
        vertical-align: middle;
        width: 18px; /* Tamanho fixo */
        height: 18px; /* Tamanho fixo */
        appearance: none; /* Remove o estilo padrão do navegador */
        -webkit-appearance: none;
        -moz-appearance: none;
        border: 2px solid var(--input-border-color);
        border-radius: 4px;
        background-color: var(--button-bg-color);
        cursor: pointer;
        position: relative;
        display: inline-block; /* Para centralizar com text-align */
      }

      #selectAllCheckbox:checked {
        background-color: var(
          --button-hover-bg-color
        ); /* Cor de fundo quando marcado */
        border-color: var(
          --button-hover-bg-color
        ); /* Cor da borda quando marcado */
      }

      #selectAllCheckbox:checked::after {
        content: "\2713"; /* Sinal de 'check' */
        color: var(--button-hover-text-color); /* Cor do sinal de check */
        font-size: 14px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

      /* Centraliza o conteúdo das colunas de checkbox e Nº */
      .checkbox-column,
      .number-column {
        text-align: center;
      }

      /* Sobrescrita de estilos para o header-controls na página index.html */
      /* Garante que o header-controls dentro do main use justify-content: center */
      main .header-controls {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        margin-bottom: 20px;
        padding: 10px 0;
        box-sizing: border-box;
      }

      /* Espaçamento entre o título e o botão de tema */
      main .header-controls h1 {
        margin-right: 15px;
        white-space: nowrap;
      }

      /* Media queries específicas da página inicial */
      @media screen and (max-width: 600px) {
        .custom-file-upload {
          padding: 10px 16px;
          font-size: 14px;
        }
        #dragDropOverlay p {
          font-size: 2em;
        }
      }
    </style>
  </head>
  <body>
    <div id="dragDropOverlay">
      <div id="dragDropArea">
        <p>Solte o MTR em qualquer lugar</p>
      </div>
    </div>

    <main id="mainContent">
      <div class="header-controls">
        <h1>Relatório de Resíduos Gerados</h1>
        <button id="themeToggle" class="theme-toggle-button">
          <i class="fas fa-moon"></i>
        </button>
      </div>
      <div class="input-container">
        <label for="pdfInput" class="custom-file-upload">
          <i class="fas fa-upload"></i> Selecionar PDFs
        </label>
        <input type="file" id="pdfInput" accept="application/pdf" multiple />
      </div>
      <div class="buttons" id="mainPageButtons">
        <!-- New buttons for edit mode will go here -->
        <button id="toggleEditModeBtn">
          <i class="fas fa-edit"></i> Editar Tabela
        </button>
        <button id="copyTableDataBtn" class="action-button">
          <i class="fas fa-copy"></i> Copiar Dados
        </button>
        <button id="batchEditBtn" class="action-button">
          <i class="fas fa-layer-group"></i> Edição em Lote (<span
            id="batchEditCount"
            >0</span
          >)
        </button>
        <button id="editSelectedBtn" class="action-button">
          <i class="fas fa-edit"></i> Editar Grupo (<span id="selectedCount"
            >0</span
          >)
        </button>
        <button id="deleteSelectedBtn" class="action-button">
          <i class="fas fa-trash"></i> Excluir Selecionados (<span
            id="deleteSelectedCount"
            >0</span
          >)
        </button>
        <!-- Botão para o Dashboard (texto alterado) -->
        <button
          class="history-button"
          id="dashboardLinkButton"
          onclick="window.location.href='dashboard/'"
        >
          <i class="fas fa-chart-bar"></i> Dashboard
        </button>
        <!-- Novo botão para o Histórico (texto alterado) -->
        <button
          class="history-button"
          id="historicalRecordsButton"
          onclick="window.location.href='historico/'"
        >
          <i class="fas fa-history"></i> Histórico
        </button>
      </div>
      <div id="textOutput"></div>
      <div id="progressIndicator"></div>
      <!-- Novo elemento para o indicador de progresso -->
      <div id="error"></div>
      <div id="messageBox"></div>
      <!-- Adicionado para mensagens de sucesso/erro -->
    </main>
    <footer>
      <img id="footerImage" src="footer.png" alt="Image of a footer" />
      <p>
        Este site foi desenvolvido para facilitar a gestão de resíduos gerados,
        oferecendo uma ferramenta prática e acessível. É livre para uso por
        todos!
      </p>
      <!-- Elemento de áudio para o som de blink -->
      <audio id="blinkAudio" preload="auto">
        <source src="blink.mp3" type="audio/mpeg" />
        Seu navegador não suporta o elemento de áudio.
      </audio>
    </footer>

    <!-- Modal de Alerta Customizado (para erros e mensagens gerais) -->
    <div id="customAlertModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="alertModalImage"
          src=""
          alt="Ícone de Status"
          class="modal-image"
        />
        <p id="alertMessage"></p>
        <div class="modal-buttons">
          <button id="alertOkBtn">OK</button>
        </div>
      </div>
    </div>

    <!-- Novo Modal de Confirmação para Pastas -->
    <div id="folderConfirmModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="folderConfirmModalImage"
          src="point.png"
          alt="Ícone de Aviso"
          class="modal-image"
        />
        <p id="folderModalMessage"></p>
        <div class="modal-buttons">
          <button id="folderModalConfirmBtn">Sim</button>
          <button id="folderModalCancelBtn">Não</button>
        </div>
      </div>
    </div>

    <!-- Modal de Edição em Massa de Grupo (antigo) -->
    <div id="bulkEditModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="bulkEditModalImage"
          src="point.png"
          alt="Ícone de Edição em Massa"
          class="modal-image"
        />
        <p id="bulkEditModalMessage">
          Editar Grupo para <span id="bulkEditSelectedCount">0</span> MTR(s):
        </p>
        <input
          type="text"
          id="bulkEditGroupInput"
          class="editable-input"
          placeholder="Nome do Grupo"
        />
        <div class="modal-buttons">
          <button id="bulkEditModalSaveBtn">Salvar</button>
          <button id="bulkEditModalCancelBtn">Cancelar</button>
        </div>
      </div>
    </div>

    <!-- Novo Modal de Edição em Lote (genérico) -->
    <div id="batchEditBatchModal" class="modal-overlay">
      <div class="modal-content">
        <img
          id="batchEditModalImage"
          src="point.png"
          alt="Ícone de Edição em Lote"
          class="modal-image"
        />
        <p id="batchEditModalMessage">
          Editar <span id="batchEditCountModal">0</span> MTR(s) selecionado(s):
        </p>
        <select id="batchEditFieldSelect" class="editable-select">
          <option value="">Selecione o campo para editar</option>
          <option value="razaoSocial1">TRANSPORTADOR</option>
          <option value="razaoSocial2">DESTINADOR</option>
          <option value="tipo">TIPO</option>
          <option value="litros">LITROS</option>
          <option value="toneladas">TONELADAS</option>
          <option value="grupo">GRUPO</option>
        </select>
        <input
          type="text"
          id="batchEditValueInput"
          class="editable-input"
          placeholder="Nova informação"
          style="display: none"
        />
        <div class="modal-buttons">
          <button id="batchEditModalSaveBtn">Salvar</button>
          <button id="batchEditModalCancelBtn">Cancelar</button>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
      // Configura o worker do PDF.js
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";

      // Variáveis globais para ordenação e edição
      let currentTableData = []; // Stores the data currently displayed in the table
      let currentSortColumn = null;
      let currentSortDirection = "asc"; // 'asc' for ascending, 'desc' for descending
      let selectedMTRs = new Set(); // Para armazenar os IDs dos MTRs selecionados na página inicial
      let isEditModeActive = false; // Novo: Estado do modo de edição na página inicial

      // Mapeamento de nomes de colunas para chaves de dados
      const columnKeys = {
        DATA: "dataEmissao",
        MTR: "mtrFormatted",
        TRANSPORTADOR: "razaoSocial1",
        DESTINADOR: "razaoSocial2",
        TIPO: "tipo",
        TICKET: "mtrRef",
        LITROS: "litros",
        TONELADAS: "toneladas",
        GRUPO: "grupo", // Adicionado para edição
      };

      // Função para alternar o tema
      function toggleTheme() {
        const htmlElement = document.documentElement;
        const currentTheme = htmlElement.getAttribute("data-theme");
        const themeToggleBtn = document.getElementById("themeToggle");

        if (currentTheme === "dark") {
          htmlElement.removeAttribute("data-theme");
          localStorage.setItem("theme", "light");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        } else {
          htmlElement.setAttribute("data-theme", "dark");
          localStorage.setItem("theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        }
      }

      // Função para aplicar o tema salvo
      function applySavedTheme() {
        const savedTheme = localStorage.getItem("theme");
        const htmlElement = document.documentElement;
        const themeToggleBtn = document.getElementById("themeToggle");

        if (savedTheme === "dark") {
          htmlElement.setAttribute("data-theme", "dark");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
          }
        } else {
          htmlElement.removeAttribute("data-theme");
          if (themeToggleBtn) {
            themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
          }
        }
      }

      // Envolve todo o código principal em um listener DOMContentLoaded
      document.addEventListener("DOMContentLoaded", () => {
        applySavedTheme(); // Aplica o tema salvo ao carregar a página

        const themeToggleBtn = document.getElementById("themeToggle");
        if (themeToggleBtn) {
          themeToggleBtn.addEventListener("click", toggleTheme);
        }

        // Mapeamento de códigos IBAMA para tipos, ajustado para consistência
        const ibamaCodeToType = {
          191213: "NÃO RECICLÁVEL",
          150202: "CONTAMINADO",
          "030101": "MADEIRA",
          "030301": "MADEIRA",
          "030308": "PAPEL",
          200139: "PLÁSTICO",
          200108: "ORGÂNICO",
          170503: "SOLO CONTAMINADO",
          170407: "SUCATA FERROSA",
          190899: "EFLUENTE SANITÁRIO",
          130201: "ÓLEO QUEIMADO",
          130507: "ÁGUA E ÓLEO",
        };
        const rccCodes = [
          "170201",
          "170202",
          "170203",
          "170401",
          "170402",
          "170403",
          "170404",
          "170405",
          "170406",
          "170411",
          "170412",
          "170413",
          "170802",
        ];

        // Função para exibir modais de alerta com imagem (para erros e mensagens gerais)
        function showAlertModal(message, type) {
          // type: 'success', 'exists', 'no_data', 'error', 'info'
          const modal = document.getElementById("customAlertModal");
          const alertMessage = document.getElementById("alertMessage");
          const alertModalImage = document.getElementById("alertModalImage");
          const okBtn = document.getElementById("alertOkBtn");

          if (alertMessage) alertMessage.textContent = message;
          if (modal) modal.classList.remove("success", "error"); // Limpa classes anteriores para evitar conflitos

          let imagePath = "";
          if (type === "success") {
            imagePath = "like.png";
            if (okBtn) okBtn.style.backgroundColor = "#4CAF50"; // Verde para sucesso
          } else if (type === "exists" || type === "info") {
            imagePath = "point.png"; // Usar 'point.png' para "já existente" e "info"
            if (okBtn) okBtn.style.backgroundColor = "#FFA000"; // Laranja para "já existente" / info
          } else if (type === "no_data" || type === "error") {
            imagePath = "doubt.png";
            if (okBtn) okBtn.style.backgroundColor = "#f44336"; // Vermelho para erro/falha
          }

          if (alertModalImage) {
            alertModalImage.src = imagePath;
            alertModalImage.style.display = "block";
          }

          // Use the 'active' class to control modal display
          if (modal) modal.classList.add("active"); // Shows the modal

          const handleOk = () => {
            closeAlertModal();
          };

          const handleKeyDown = (e) => {
            if (e.key === "Enter" || e.key === "Escape") {
              e.preventDefault(); // Prevents default behavior (e.g., submitting forms, closing browser search)
              handleOk();
            }
          };

          const closeAlertModal = () => {
            if (modal) modal.classList.remove("active"); // Hides the modal
            if (okBtn) okBtn.removeEventListener("click", handleOk);
            document.removeEventListener("keydown", handleKeyDown); // Remove keyboard listener
            if (alertModalImage) alertModalImage.style.display = "none"; // Oculta a imagem ao fechar
          };

          // Ensure listeners are added only once
          // Clone and replace to remove old listeners robustly
          const newOkBtn = okBtn.cloneNode(true);
          okBtn.parentNode.replaceChild(newOkBtn, okBtn);

          newOkBtn.addEventListener("click", handleOk);
          document.addEventListener("keydown", handleKeyDown); // Add keyboard listener
        }

        // Nova função para o modal de confirmação de pasta
        function showFolderConfirmModal(message) {
          return new Promise((resolve) => {
            const modal = document.getElementById("folderConfirmModal");
            const modalMessage = document.getElementById("folderModalMessage");
            const confirmModalImage = document.getElementById(
              "folderConfirmModalImage"
            );
            const confirmBtn = document.getElementById("folderModalConfirmBtn");
            const cancelBtn = document.getElementById("folderModalCancelBtn");

            if (modalMessage) modalMessage.textContent = message;
            if (confirmModalImage) {
              confirmModalImage.src = "point.png"; // Ícone de "ponto de atenção"
              confirmModalImage.style.display = "block";
            }
            // Use the 'active' class to control modal display
            if (modal) modal.classList.add("active"); // Shows the modal

            const handleConfirm = () => {
              resolve(true);
              closeFolderConfirmModal();
            };

            const handleCancel = () => {
              resolve(false);
              closeFolderConfirmModal();
            };

            const handleKeyDown = (e) => {
              if (e.key === "Enter") {
                e.preventDefault(); // Prevents default Enter behavior (e.g., submitting forms)
                handleConfirm();
              } else if (e.key === "Escape") {
                e.preventDefault(); // Prevents default Esc behavior
                handleCancel();
              }
            };

            const closeFolderConfirmModal = () => {
              if (modal) modal.classList.remove("active"); // Hides the modal
              if (confirmBtn)
                confirmBtn.removeEventListener("click", handleConfirm);
              if (cancelBtn)
                cancelBtn.removeEventListener("click", handleCancel);
              document.removeEventListener("keydown", handleKeyDown); // Remove keyboard listener
              if (confirmModalImage) confirmModalImage.style.display = "none"; // Oculta a imagem ao fechar
            };

            // Ensure listeners are added only once
            // Clone and replace to remove old listeners robustly
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            newConfirmBtn.addEventListener("click", handleConfirm);
            newCancelBtn.addEventListener("click", handleCancel);
            document.addEventListener("keydown", handleKeyDown); // Add keyboard listener
          });
        }

        // Função para extrair dados do texto (usada por processPdfFile)
        async function extractData(text) {
          const extracted = {};

          const dataEmissaoMatch = text.match(
            /Data\s*da\s*emissão:?\s*(\d{2}\/\d{2}\/\d{4})/i
          );
          extracted.dataEmissao = dataEmissaoMatch
            ? dataEmissaoMatch[1]
            : "Não encontrada";

          // Modificação: Ajusta a regex para capturar MTR nº/n° ou MTR sem número
          const mtrMatch = text.match(/MTR\s*n[ºo°]:?\s*(\d+)/i);
          extracted.mtr = mtrMatch ? mtrMatch[1] : "Não encontrado";
          extracted.mtrFormatted = mtrMatch
            ? `MTR nº: ${mtrMatch[1]}`
            : "Não encontrado";

          // CORREÇÃO AQUI: Torna o "Ticket " opcional e lida com "nº" ou "n°" e espaços
          const mtrRefMatch = text.match(
            /Referente\s*ao\s*(?:Ticket\s*)?(?:MTR|CCO)\s*(?:n[ºo°]\s*)?(\d+)/i
          );
          extracted.mtrRef = mtrRefMatch ? mtrRefMatch[1] : "N/A";

          const razaoInicialMatches = text.matchAll(
            /Raz[ãa]o\s*Social:?\s*([^:]+?)(?=\s*(?:Raz[ãa]o\s*Social|Telefone|Endereço|$))/gi
          );
          let razoesIniciais = Array.from(razaoInicialMatches, (match) =>
            match[1].trim().split("-")[0].trim()
          );

          const razaoDestinadorMatch = text.match(
            /Identificação\s*do\s*Destinador.*?Raz[ãa]o\s*Social:?\s*([^:]+?)(?=\s*(?:Estado|Município|$))/is
          );
          const razaoDestinador = razaoDestinadorMatch
            ? razaoDestinadorMatch[1].trim().split("-")[0].trim()
            : null;

          let razoesSociais = [...razoesIniciais];
          if (razaoDestinador) razoesSociais.push(razaoDestinador);
          razoesSociais = razoesSociais.filter(
            (razao) =>
              !razao
                .toUpperCase()
                .includes("CONSORCIO CONSTRUTOR FERROVIA LUCAS DO RIO VERDE")
          );

          extracted.razaoSocial1 =
            razoesSociais.length > 0 ? razoesSociais[0] : "Não encontrada";
          extracted.razaoSocial2 =
            razoesSociais.length > 1
              ? razoesSociais[1]
              : razoesSociais.length === 1
              ? razoesSociais[0]
              : "Não encontrada";

          const estadoFisicoMatch = text.match(/.*?(SÓLIDO|LÍQUIDO)\s*CLASSE/i);
          extracted.estadoFisico = estadoFisicoMatch
            ? estadoFisicoMatch[1]
            : "Não encontrado";

          const quantidadeMatch = text.match(/Qtde.*?(\d+,\d{4})/i);
          let quantidade = quantidadeMatch
            ? quantidadeMatch[1]
            : "Não encontrada";

          const unidadeMatch = text.match(/\s(KG|TON)\s/i);
          const unidade = unidadeMatch ? unidadeMatch[1].toUpperCase() : "";

          const ibamaMatch = text.match(
            /Código\s*IBAMA\s*e\s*Denominação.*?(\d{6}(?:\(*\))?)/is
          );
          const ibamaCode = ibamaMatch
            ? ibamaMatch[1].replace(/\(.*\)/, "").trim()
            : "Não encontrado";
          if (ibamaCode === "Não encontrado") {
            extracted.tipo = "Não encontrado";
          } else if (ibamaCodeToType[ibamaCode]) {
            extracted.tipo = ibamaCodeToType[ibamaCode];
          } else if (rccCodes.includes(ibamaCode)) {
            extracted.tipo = "RCC";
          } else {
            extracted.tipo = ibamaCode;
          }

          // Nova lógica: Se o tipo for "ÓLEO QUEIMADO", sempre use toneladas
          if (extracted.tipo === "ÓLEO QUEIMADO") {
            extracted.litros = "";
            extracted.toneladas = quantidade;
          } else {
            extracted.litros =
              extracted.estadoFisico === "LÍQUIDO" ? quantidade : "";
            extracted.toneladas =
              extracted.estadoFisico === "SÓLIDO" ? quantidade : "";
          }
          // Garante que a propriedade `grupo` exista e seja inicializada vazia
          extracted.grupo = "";

          if (
            extracted.toneladas &&
            unidade === "KG" &&
            extracted.tipo === "RCC"
          ) {
            extracted.toneladas = (
              parseFloat(quantidade.replace(",", ".")) / 1000
            )
              .toFixed(4)
              .replace(".", ",");
          }

          return extracted;
        }

        // Função para processar um único arquivo PDF
        async function processPdfFile(file) {
          // Verifica o tipo de arquivo antes de carregar
          if (file.type !== "application/pdf") {
            throw new Error("not-pdf");
          }

          const arrayBuffer = await file.arrayBuffer();
          const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

          if (pdf.numPages > 1) {
            throw new Error("multi-page-pdf"); // Erro customizado para PDFs com mais de uma página
          }

          let fullText = "";
          const page = await pdf.getPage(1); // Processa apenas a primeira página
          const textContent = await page.getTextContent();
          const pageText = textContent.items.map((item) => item.str).join(" ");
          fullText += pageText + " ";

          return extractData(fullText); // Chama a função extractData
        }

        // Função para trocar a imagem do rodapé e reproduzir áudio
        function swapFooterImage(imgElement) {
          const originalSrc = imgElement.src;
          const blinkSrc = originalSrc.replace("footer.png", "blink.png");
          const audio = document.getElementById("blinkAudio");

          imgElement.src = blinkSrc;
          if (audio) {
            audio.currentTime = 0; // Reinicia o áudio se já estiver tocando
            audio
              .play()
              .catch((e) => console.error("Erro ao reproduzir áudio:", e));
          }
          setTimeout(() => {
            imgElement.src = originalSrc;
          }, 400); // Alterado para 400 milissegundos
        }

        // Função para copiar texto para a área de transferência
        function copyToClipboard(text) {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          // Torna o textarea invisível
          textarea.style.position = "fixed";
          textarea.style.top = "0";
          textarea.style.left = "0";
          textarea.style.width = "1em";
          textarea.style.height = "1em";
          textarea.style.border = "none";
          textarea.style.outline = "none";
          textarea.style.boxShadow = "none";
          textarea.style.background = "transparent";
          document.body.appendChild(textarea);
          textarea.focus();
          textarea.select();
          try {
            const successful = document.execCommand("copy");
            return successful;
          } catch (err) {
            console.error("Erro ao copiar:", err);
            return false;
          } finally {
            document.body.removeChild(textarea);
          }
        }

        // Função para copiar os dados da tabela para a área de transferência
        function copyTableDataToClipboard() {
          if (currentTableData.length === 0) {
            showAlertModal("Nenhum dado na tabela para copiar.", "no_data");
            return;
          }

          let clipboardText = "";
          // Define the columns to include and their order (excluding 'grupo')
          const columnsToCopy = [
            { header: "DATA", key: "dataEmissao" },
            { header: "MTR", key: "mtrFormatted" },
            { header: "TRANSPORTADOR", key: "razaoSocial1" },
            { header: "DESTINADOR", key: "razaoSocial2" },
            { header: "TIPO", key: "tipo" },
            { header: "TICKET", key: "mtrRef" },
            { header: "LITROS", key: "litros" },
            { header: "TONELADAS", key: "toneladas" },
          ];

          // NÃO adiciona os cabeçalhos à string de cópia.
          // Comentado para evitar copiar os cabeçalhos:
          // const headerTexts = columnsToCopy.map((col) => col.header);
          // clipboardText += headerTexts.join("\t") + "\n";

          // Adiciona as linhas, mapeando apenas as colunas desejadas
          currentTableData.forEach((item) => {
            const rowData = columnsToCopy.map((col) => item[col.key] || ""); // Usa o objeto de dados real
            clipboardText += rowData.join("\t") + "\n";
          });

          if (copyToClipboard(clipboardText)) {
            showAlertModal(
              "Dados da tabela copiados para a área de transferência!",
              "success"
            );
          } else {
            showAlertModal(
              "Falha ao copiar os dados para a área de transferência. Por favor, tente novamente.",
              "error"
            );
          }
        }

        /**
         * Reads entries from a directory recursively.
         * @param {FileSystemDirectoryEntry} directoryEntry The directory entry to read.
         * @param {Array<File>} filesArray The array to accumulate files.
         * @param {Set<string>} uniqueFileIdentifiers Set to track unique files by identifier.
         * @returns {Promise<void>} A promise that resolves when all files are read.
         */
        async function readDirectoryEntries(
          directoryEntry,
          filesArray,
          uniqueFileIdentifiers
        ) {
          return new Promise((resolve) => {
            const directoryReader = directoryEntry.createReader();
            let entries = [];

            const readBatch = () => {
              directoryReader.readEntries(async (batch) => {
                if (!batch.length) {
                  // No more entries, process them
                  for (const entry of entries) {
                    if (entry.isFile) {
                      const file = await new Promise((res) => entry.file(res));
                      if (file) {
                        // Use a more robust identifier for uniqueness
                        const identifier = `${file.name}-${file.size}-${file.lastModified}`;
                        if (!uniqueFileIdentifiers.has(identifier)) {
                          filesArray.push(file);
                          uniqueFileIdentifiers.add(identifier);
                        } else {
                          console.warn(
                            `[Deduplicação] Arquivo duplicado (dentro da pasta) ignorado na coleta: ${file.name}`
                          );
                        }
                      }
                    } else if (entry.isDirectory) {
                      // Recursively call for subdirectories
                      await readDirectoryEntries(
                        entry,
                        filesArray,
                        uniqueFileIdentifiers
                      );
                    }
                  }
                  resolve();
                } else {
                  entries = entries.concat(Array.from(batch));
                  readBatch(); // Continue reading the next batch
                }
              });
            };
            readBatch();
          });
        }

        // Função para salvar alterações de célula individual (na página inicial)
        function saveIndividualCellChange(e) {
          console.log("saveIndividualCellChange called.");
          const input = e.target;
          const mtrId = input.dataset.mtrId;
          const dateId = input.dataset.dateId;
          const columnKey = input.dataset.columnKey;
          const newValue = input.value.trim();

          // Encontra o item em currentTableData
          const itemIndex = currentTableData.findIndex(
            (item) => item.mtrFormatted === mtrId && item.dataEmissao === dateId
          );

          if (itemIndex > -1) {
            const originalValue = currentTableData[itemIndex][columnKey];
            if (originalValue !== newValue) {
              // Validação para campos numéricos
              if (columnKey === "litros" || columnKey === "toneladas") {
                const parsedValue = parseFloat(newValue.replace(",", "."));
                if (isNaN(parsedValue)) {
                  showAlertModal(
                    `Valor inválido para ${columnKey}. Por favor, insira um número.`,
                    "error"
                  );
                  input.value = originalValue; // Reverte o valor do input
                  return;
                }
                currentTableData[itemIndex][columnKey] = newValue; // Salva como string com vírgula
              } else {
                currentTableData[itemIndex][columnKey] = newValue;
              }

              // Atualiza também o localStorage
              let storedData = JSON.parse(
                localStorage.getItem("residuosData") || "[]"
              );
              const storedItemIndex = storedData.findIndex(
                (item) =>
                  item.mtrFormatted === mtrId && item.dataEmissao === dateId
              );
              if (storedItemIndex > -1) {
                storedData[storedItemIndex][columnKey] =
                  currentTableData[itemIndex][columnKey];
                localStorage.setItem(
                  "residuosData",
                  JSON.stringify(storedData)
                );
                console.log(
                  `Dados salvos no localStorage para MTR ${mtrId}, coluna ${columnKey}.`
                );
              } else {
                console.warn(
                  `Item não encontrado no localStorage para MTR ${mtrId}, coluna ${columnKey}.`
                );
              }

              showAlertModal(
                `Campo '${columnKey}' atualizado para '${newValue}'.`,
                "success"
              );
              // No need to re-render the whole table here, just update the cell value
              // renderTable(currentTableData); // Removed to avoid losing focus if many edits are made
            }
          } else {
            console.warn(
              `Item não encontrado em currentTableData para MTR ${mtrId}.`
            );
          }
        }

        // Função para alternar o modo de edição (na página inicial)
        function toggleEditMode() {
          console.log(
            "toggleEditMode called. isEditModeActive before:",
            isEditModeActive
          );
          isEditModeActive = !isEditModeActive;
          const toggleEditModeBtn =
            document.getElementById("toggleEditModeBtn");
          if (toggleEditModeBtn) {
            if (isEditModeActive) {
              toggleEditModeBtn.innerHTML =
                '<i class="fas fa-check"></i> Encerrar Edição';
              showAlertModal(
                "Modo de edição ativado. Clique nas células para editar.",
                "info"
              );
            } else {
              toggleEditModeBtn.innerHTML =
                '<i class="fas fa-edit"></i> Editar Tabela';
              // No need to show alert here, as changes are saved on blur/enter.
              // showAlertModal("Modo de edição desativado. Alterações salvas.", "success");
            }
          }
          renderTable(currentTableData); // Re-renderiza a tabela para aplicar/remover inputs editáveis
          updateActionButtonsVisibility(); // Ajusta a visibilidade de outros botões
          console.log(
            "toggleEditMode finished. isEditModeActive after:",
            isEditModeActive
          );
        }

        /**
         * Renders the data in the table.
         * @param {Array<Object>} dataToRender The array of MTR objects to display.
         */
        function renderTable(dataToRender) {
          const textOutput = document.getElementById("textOutput");
          currentTableData = dataToRender; // Update the global variable
          selectedMTRs.clear(); // Clear selections on re-render

          if (dataToRender.length === 0) {
            if (textOutput) textOutput.innerHTML = "";
            updateActionButtonsVisibility(); // Important: update buttons if table becomes empty
            return;
          }

          // Define a ordem e as chaves para as colunas da tabela
          const orderedColumnKeys = [
            { header: "DATA", key: "dataEmissao" },
            { header: "MTR", key: "mtrFormatted" },
            { header: "TRANSPORTADOR", key: "razaoSocial1" },
            { header: "DESTINADOR", key: "razaoSocial2" },
            { header: "TIPO", key: "tipo" },
            { header: "TICKET", key: "mtrRef" },
            { header: "LITROS", key: "litros" },
            { header: "TONELADAS", key: "toneladas" },
            { header: "GRUPO", key: "grupo" }, // Adicionado para edição
          ];

          let tableHeadersHtml = `
              <th class="checkbox-column"><input type="checkbox" id="selectAllCheckbox"></th>
              <th class="number-column">Nº</th>
          `;
          orderedColumnKeys.forEach((col) => {
            tableHeadersHtml += `<th data-column="${col.key}">${col.header} <span class="sort-arrow"></span></th>`;
          });

          let tableRows = dataToRender
            .map((data, index) => {
              let cellsHtml = "";
              // Coluna do Checkbox
              cellsHtml += `<td class="checkbox-column"><input type="checkbox" class="row-checkbox" data-mtr-id="${data.mtrFormatted}" data-date-id="${data.dataEmissao}"></td>`;
              // Coluna do Número
              cellsHtml += `<td class="number-column">${index + 1}</td>`;

              orderedColumnKeys.forEach((col) => {
                let cellContent = data[col.key] || "";
                if (isEditModeActive) {
                  cellsHtml += `<td>
                                          <input type="text" class="editable-table-input" value="${cellContent}"
                                                 data-column-key="${col.key}"
                                                 data-mtr-id="${data.mtrFormatted}"
                                                 data-date-id="${data.dataEmissao}">
                                        </td>`;
                } else {
                  cellsHtml += `<td>${cellContent}</td>`;
                }
              });

              return `<tr data-mtr-id="${data.mtrFormatted}" data-date-id="${data.dataEmissao}">${cellsHtml}</tr>`;
            })
            .join("");

          if (textOutput) {
            textOutput.innerHTML = `
                      <div class="table-container">
                        <table>
                          <thead>
                            <tr>
                              ${tableHeadersHtml}
                            </tr>
                          </thead>
                          <tbody>
                            ${tableRows}
                          </tbody>
                        </table>
                      </div>
                  `;
          }

          // Add sorting event listeners to headers
          const headers = textOutput.querySelectorAll("th[data-column]");
          headers.forEach((header) => {
            header.addEventListener("click", () => {
              const column = header.dataset.column;
              sortTable(column);
            });
          });

          // Update sort arrows
          updateSortArrows();

          // Add listeners for individual cell edits if in edit mode
          if (isEditModeActive) {
            textOutput
              .querySelectorAll(".editable-table-input")
              .forEach((input) => {
                input.addEventListener("blur", saveIndividualCellChange);
                input.addEventListener("keydown", (e) => {
                  if (e.key === "Enter") {
                    input.blur();
                  }
                  if (e.key === "Escape") {
                    const mtrId = input.dataset.mtrId;
                    const dateId = input.dataset.dateId;
                    const columnKey = input.dataset.columnKey;
                    const item = currentTableData.find(
                      (d) =>
                        d.mtrFormatted === mtrId && d.dataEmissao === dateId
                    );
                    if (item) {
                      input.value = item[columnKey] || "";
                    }
                    input.blur();
                  }
                });
              });
          }

          // Event listener for checkbox interactions
          const tableContainer = document.querySelector(
            "#textOutput .table-container"
          );
          if (tableContainer) {
            // Remove existing listeners to prevent duplicates after re-rendering
            const oldSelectAllCheckbox =
              document.getElementById("selectAllCheckbox");
            if (oldSelectAllCheckbox) {
              const newSelectAllCheckbox = oldSelectAllCheckbox.cloneNode(true);
              oldSelectAllCheckbox.parentNode.replaceChild(
                newSelectAllCheckbox,
                oldSelectAllCheckbox
              );
              newSelectAllCheckbox.addEventListener("change", (e) => {
                const selectAllCheckbox = e.target;
                const allCheckboxes = document.querySelectorAll(
                  "#textOutput .row-checkbox"
                );
                selectedMTRs.clear();
                allCheckboxes.forEach((cb) => {
                  cb.checked = selectAllCheckbox.checked;
                  if (selectAllCheckbox.checked) {
                    selectedMTRs.add(
                      `${cb.dataset.mtrId}_${cb.dataset.dateId}`
                    );
                  }
                });
                updateActionButtonsVisibility();
              });
            }

            // Event delegation for row checkboxes
            tableContainer.addEventListener("change", (e) => {
              if (e.target.matches(".row-checkbox")) {
                const checkbox = e.target;
                const mtrId = checkbox.dataset.mtrId;
                const dateId = checkbox.dataset.dateId;
                const uniqueId = `${mtrId}_${dateId}`;

                if (checkbox.checked) {
                  selectedMTRs.add(uniqueId);
                } else {
                  selectedMTRs.delete(uniqueId);
                }
                updateActionButtonsVisibility();
                // Update "Select All" checkbox status
                const allCheckboxes = document.querySelectorAll(
                  "#textOutput .row-checkbox"
                );
                const selectAllCheckbox =
                  document.getElementById("selectAllCheckbox");
                if (selectAllCheckbox) {
                  selectAllCheckbox.checked =
                    selectedMTRs.size === allCheckboxes.length &&
                    allCheckboxes.length > 0;
                }
              }
            });
          }

          updateActionButtonsVisibility(); // Update button visibility after rendering
        }

        /**
         * Sorts the currentTableData based on the selected column.
         * @param {string} column The data key to sort by.
         */
        function sortTable(column) {
          console.log("sortTable called with column:", column);
          // Determine sort direction
          if (currentSortColumn === column) {
            currentSortDirection =
              currentSortDirection === "asc" ? "desc" : "asc";
          } else {
            currentSortColumn = column;
            currentSortDirection = "asc";
          }

          currentTableData.sort((a, b) => {
            let valA = a[column];
            let valB = b[column];

            // Special handling for numeric values (litros, toneladas, MTR, Ticket)
            if (
              column === "litros" ||
              column === "toneladas" ||
              column === "mtrFormatted" ||
              column === "mtrRef"
            ) {
              // Remove "MTR nº: " prefix for MTR, and handle comma as decimal separator for numbers
              if (column === "mtrFormatted")
                valA = String(valA).replace("MTR nº: ", "");
              if (column === "mtrFormatted")
                valB = String(valB).replace("MTR nº: ", "");

              valA = parseFloat(String(valA).replace(",", ".") || 0);
              valB = parseFloat(String(valB).replace(",", ".") || 0);

              if (isNaN(valA)) valA = -Infinity; // Treat "Não encontrada" or "N/A" as smallest
              if (isNaN(valB)) valB = -Infinity;

              return currentSortDirection === "asc" ? valA - valB : valB - valA;
            }

            // Special handling for date (DD/MM/YYYY)
            if (column === "dataEmissao") {
              // Convert DD/MM/YYYY to ISO నేపథ్యంలో-MM-DD for correct comparison
              const dateA = valA.split("/").reverse().join("-");
              const dateB = valB.split("/").reverse().join("-");
              if (dateA < dateB) return currentSortDirection === "asc" ? -1 : 1;
              if (dateA > dateB) return currentSortDirection === "asc" ? 1 : -1;
              return 0;
            }

            // Default string comparison
            if (typeof valA === "string" && typeof valB === "string") {
              valA = valA.toLowerCase();
              valB = valB.toLowerCase();
              if (valA < valB) return currentSortDirection === "asc" ? -1 : 1;
              if (valA > valB) return currentSortDirection === "asc" ? 1 : -1;
            }
            return 0;
          });

          renderTable(currentTableData); // Re-render the table with sorted data
        }

        /**
         * Updates the sort arrows in the table headers.
         */
        function updateSortArrows() {
          const headers = document.querySelectorAll("#textOutput th");
          headers.forEach((header) => {
            let arrowSpan = header.querySelector(".sort-arrow");
            if (!arrowSpan) {
              // Create if it doesn't exist
              arrowSpan = document.createElement("span");
              arrowSpan.classList.add("sort-arrow");
              header.appendChild(arrowSpan);
            }
            arrowSpan.textContent = ""; // Clear previous arrow
            // Only add arrow to sortable columns
            if (header.dataset.column === currentSortColumn) {
              arrowSpan.textContent =
                currentSortDirection === "asc" ? " ↑" : " ↓";
            }
          });
        }

        // Function to handle files from input or drag-and-drop
        async function handleFiles(source) {
          let filesToProcess = []; // Moved declaration to the top
          const uniqueFileIdentifiers = new Set(); // For deduplication

          console.log("handleFiles called.");
          const textOutput = document.getElementById("textOutput");
          const errorDiv = document.getElementById("error");
          const messageBox = document.getElementById("messageBox");
          const progressIndicator =
            document.getElementById("progressIndicator");

          // Clear previous messages and indicators
          if (textOutput) textOutput.innerHTML = "";
          if (errorDiv) errorDiv.style.display = "none";
          if (messageBox) {
            messageBox.style.display = "none";
            messageBox.classList.remove(
              "success",
              "error",
              "exists",
              "no_data"
            );
          }
          // Display initial loading message
          if (progressIndicator) {
            progressIndicator.innerHTML = `<span>Carregando 0 de ${filesToProcess.length} arquivos...</span><span>(Aguarde...)</span>`;
          }

          // Function to add a file to filesToProcess if it's unique
          function addFileIfUnique(file) {
            if (!file || !(file instanceof File)) {
              console.warn(
                "[Coleta] Objeto inválido tentado adicionar à fila de processamento (não é um File):",
                file
              );
              return;
            }

            // Ensure file.size and file.lastModified are valid numbers
            const fileSize = typeof file.size === "number" ? file.size : 0;
            const fileLastModified =
              typeof file.lastModified === "number" ? file.lastModified : 0;

            const identifier = `${file.name}-${fileSize}-${file.lastModified}`;

            if (!uniqueFileIdentifiers.has(identifier)) {
              filesToProcess.push(file);
              uniqueFileIdentifiers.add(identifier);
              console.log(
                `[Coleta - Adicionado] Arquivo: ${file.name} (ID: ${identifier}). Total na fila: ${filesToProcess.length}`
              ); // New log
            } else {
              console.warn(
                `[Deduplicação - Ignorado] Arquivo: ${file.name} (ID: ${identifier}) já presente na lista.`
              ); // Enhanced log
            }
          }

          // Scenario 1: From <input type="file"> (FileList)
          if (source instanceof FileList) {
            console.log(
              `[Coleta] Fonte: FileList (do input type=file). Total de arquivos na seleção: ${source.length}`
            ); // New log
            Array.from(source).forEach((file) => addFileIfUnique(file));
          }
          // Scenario 2: From Drag and Drop (DataTransfer object)
          else if (source instanceof DataTransfer) {
            console.log("[Coleta] Fonte: DataTransfer (do arrastar e soltar).");

            // --- PRIORITY: Process files from DataTransfer.files first ---
            // This is generally the most reliable way to get actual File objects from a drag,
            // especially for multiple individual files.
            if (source.files && source.files.length > 0) {
              console.log(
                `[Coleta] Tentando coletar ${source.files.length} arquivos diretamente de DataTransfer.files.`
              );
              Array.from(source.files).forEach((file) => {
                addFileIfUnique(file);
              });
              console.log(
                `[Coleta] Arquivos coletados de DataTransfer.files: ${filesToProcess.length} (após deduplicação inicial).`
              );
            }

            // --- SECONDARY: Iterate DataTransfer.items to handle directory entries ---
            // This is primarily for detecting and processing dropped folders, as DataTransfer.files
            // flattens the hierarchy and doesn't explicitly mark directories.
            if (source.items) {
              console.log(
                `[Coleta] Verificando ${source.items.length} itens de DataTransfer.items para pastas.`
              );
              for (const item of Array.from(source.items)) {
                if (item.webkitGetAsEntry) {
                  // Check for webkitGetAsEntry support
                  const entry = item.webkitGetAsEntry();
                  if (entry) {
                    // Ensure entry is not null
                    if (entry.isDirectory) {
                      console.log(`[Coleta] Pasta detectada: "${entry.name}"`);
                      const confirmed = await showFolderConfirmModal(
                        `Uma pasta foi detectada: "${entry.name}". Deseja processar os arquivos MTR dentro dela?`
                      );
                      if (confirmed) {
                        await readDirectoryEntries(
                          entry,
                          filesToProcess,
                          uniqueFileIdentifiers
                        );
                        console.log(
                          `[Coleta] Arquivos adicionados da pasta "${entry.name}". Total atual: ${filesToProcess.length}`
                        );
                      } else {
                        console.log(
                          `[Coleta] Processamento da pasta "${entry.name}" cancelado pelo usuário.`
                        );
                      }
                    }
                    // If it's entry.isFile, it should have already been caught by DataTransfer.files above.
                    // We rely on addFileIfUnique to prevent duplicates if it happens to be processed again.
                  } else {
                    console.warn(
                      `[Coleta] webkitGetAsEntry retornou nulo para item do tipo: ${
                        item.kind || "desconhecido"
                      } - ${item.type || "desconhecido"}.`
                    );
                  }
                } else if (item.kind === "file" && item.getAsFile) {
                  // Fallback for browsers that's don't support webkitGetAsEntry well for files,
                  // or for simple file drops where getAsFile() might be the primary method.
                  try {
                    const file = item.getAsFile();
                    if (file) {
                      addFileIfUnique(file);
                      console.log(
                        `[Coleta] Arquivo via item.getAsFile (fallback): ${file.name}`
                      );
                    } else {
                      console.warn(
                        `[Coleta] item.getAsFile: Objeto File não obtido para item ${
                          item.type || "desconhecido"
                        }.`
                      );
                    }
                  } catch (e) {
                    console.error(
                      `[Coleta] Erro ao obter arquivo via item.getAsFile(): ${e}`
                    );
                  }
                }
              }
            } else {
              console.warn(
                "[Coleta] DataTransfer.items não disponível ou vazio."
              );
            }
          } else {
            showAlertModal(
              "Nenhum arquivo ou pasta foi selecionado ou solto.",
              "no_data"
            );
            if (progressIndicator) progressIndicator.innerHTML = "";
            return;
          }

          // At this point, filesToProcess should contain only unique File objects, ready for PDF processing.

          if (filesToProcess.length === 0) {
            showAlertModal(
              "Nenhum arquivo PDF válido encontrado para processar na seleção (ou o processamento das pastas foi cancelado/estavam vazias/não continham PDFs válidos).",
              "no_data"
            );
            if (progressIndicator) progressIndicator.innerHTML = "";
            return;
          }

          console.log(
            `[Coleta Final] Total de arquivos PDF únicos a serem processados: ${filesToProcess.length}`
          );

          let extractedDataResults = []; // Stores results of all PDF processing attempts
          let nonPdfCount = 0;
          let multiPageCount = 0;
          let noMtrDataCount = 0; // PDFs that were valid but had no MTR data
          let otherErrorCount = 0; // For errors during PDF loading/parsing
          // These counts will now refer to the final outcomes based on MTR data, not just file types
          let newUniqueDataCount = 0; // MTRs that are truly new and added to localStorage
          let existingDuplicatesInLocalStorageCount = 0; // MTRs already present in localStorage
          let duplicatesInCurrentSelectionCount = 0; // MTRs duplicated within the current drag/select operation

          // Update progress indicator before starting the loop
          if (progressIndicator) {
            progressIndicator.innerHTML = `<span>Processando 0 de ${filesToProcess.length} arquivos...</span><span>(Aguarde...)</span>`;
          }

          for (const file of filesToProcess) {
            if (progressIndicator) {
              // Update progress for each file iteration
              progressIndicator.innerHTML = `<span>Processando arquivo ${
                extractedDataResults.length + 1
              } de ${filesToProcess.length}...</span><span>(${
                file.name
              })</span>`;
            }
            console.log(
              `[Processamento] Iniciando processamento de: ${file.name}`
            );

            try {
              const pdfData = await processPdfFile(file);
              extractedDataResults.push({
                ...pdfData,
                _processedSuccessfully: true,
                _fileName: file.name,
              });
              console.log(
                `[Processamento] Sucesso na extração para ${file.name}.`
              );
            } catch (error) {
              if (error.message === "multi-page-pdf") {
                multiPageCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "multi-page",
                  _fileName: file.name,
                });
                console.warn(
                  `[Processamento] Arquivo ignorado (mais de uma página): ${file.name}`
                );
              } else if (error.message === "not-pdf") {
                nonPdfCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "not-pdf",
                  _fileName: file.name,
                });
                console.warn(
                  `[Processamento] Arquivo ignorado (não é PDF): ${file.name}`
                );
              } else {
                otherErrorCount++;
                extractedDataResults.push({
                  _processedSuccessfully: false,
                  _reason: "other-error",
                  _fileName: file.name,
                  _errorMessage: error.message,
                });
                console.error(
                  `[Processamento] Erro ao processar arquivo ${file.name}:`,
                  error
                );
              }
            }
          }

          // Clear progress indicator after processing
          if (progressIndicator) {
            progressIndicator.innerHTML = "";
          }

          let storedData = JSON.parse(
            localStorage.getItem("residuosData") || "[]"
          );
          const tempDataForTableDisplay = []; // This will only contain unique, new MTRs for the current display
          const mtrsAddedToTempDisplay = new Set(); // To prevent duplicates in current table display

          console.log(
            `[Verificação Duplicatas] Iniciando verificação de duplicatas. Total atual em localStorage: ${storedData.length}`
          );
          extractedDataResults.forEach((item) => {
            if (item._processedSuccessfully) {
              const { _processedSuccessfully, _fileName, ...cleanItem } = item;

              // Check if extracted data meets criteria for a "valid MTR"
              if (
                cleanItem.dataEmissao !== "Não encontrada" &&
                cleanItem.mtrFormatted !== "Não encontrado" &&
                cleanItem.razaoSocial1 !== "Não encontrada" &&
                cleanItem.razaoSocial2 !== "Não encontrada" &&
                cleanItem.tipo !== "Não encontrado"
              ) {
                const currentMtrIdentifier = `${cleanItem.mtrFormatted}-${cleanItem.dataEmissao}`;

                const isDuplicateInLocalStorage = storedData.some(
                  (existingItem) =>
                    `${existingItem.mtrFormatted}-${existingItem.dataEmissao}` ===
                    currentMtrIdentifier
                );

                const isDuplicateInCurrentDisplay =
                  mtrsAddedToTempDisplay.has(currentMtrIdentifier);

                if (
                  !isDuplicateInLocalStorage &&
                  !isDuplicateInCurrentDisplay
                ) {
                  storedData.push(cleanItem); // Add to main list in localStorage
                  newUniqueDataCount++;
                  tempDataForTableDisplay.push(cleanItem); // Add for current table display
                  mtrsAddedToTempDisplay.add(currentMtrIdentifier); // Mark as added to current display
                  console.log(
                    `[Verificação Duplicatas] NOVO: MTR: ${cleanItem.mtrFormatted} (Data: ${cleanItem.dataEmissao}) - Arquivo: ${_fileName} adicionado ao histórico e exibição.`
                  );
                } else if (isDuplicateInLocalStorage) {
                  existingDuplicatesInLocalStorageCount++;
                  console.log(
                    `[Verificação Duplicatas] EXISTENTE (no histórico): MTR: ${cleanItem.mtrFormatted} (Data: ${cleanItem.dataEmissao}) - Arquivo: ${_fileName} já existe no histórico.`
                  );
                  // We do NOT add to tempDataForTableDisplay here, as per requirement
                } else if (isDuplicateInCurrentDisplay) {
                  duplicatesInCurrentSelectionCount++;
                  console.warn(
                    `[Verificação Duplicatas] DUPLICADO (na seleção atual): MTR: ${cleanItem.mtrFormatted} (Data: ${cleanItem.dataEmissao}) - Arquivo: ${_fileName} é duplicado na seleção atual e não será exibido na tabela.`
                  );
                  // We do NOT add to tempDataForTableDisplay here, as per requirement
                }
              } else {
                noMtrDataCount++; // Count PDFs that did not yield valid MTR data
                console.warn(
                  `[Verificação Duplicatas] PDF sem dados MTR válidos (MTR não extraído) para arquivo: ${_fileName}`
                );
              }
            } else {
              // Log details for files that failed initial PDF processing (e.g., non-PDF, multi-page)
              console.warn(
                `[Verificação Duplicatas] Arquivo não processado com sucesso: ${
                  item._fileName || "Nome de arquivo desconhecido"
                } - Razão: ${item._reason || "Desconhecida"}`
              );
            }
          });

          // Save updated data to localStorage
          localStorage.setItem("residuosData", JSON.stringify(storedData));
          console.log(
            `[Verificação Duplicatas] Histórico final salvo. Total de MTRs no histórico: ${storedData.length}`
          );

          // Set currentTableData for sorting and display
          currentTableData = tempDataForTableDisplay;

          // Render table ONLY if there is data to display in this execution
          renderTable(currentTableData);

          // --- Final Feedback Message Logic ---
          let feedbackMessageParts = [];
          let feedbackType = "no_data"; // Default: no valid data found

          // Helper function for pluralization
          const pluralize = (count, singular, plural) =>
            count === 1 ? singular : plural;

          // Base message about total files attempted to be processed
          let totalFilesAttemptedForProcessing = filesToProcess.length; // Number of unique file objects processed

          if (newUniqueDataCount > 0) {
            feedbackMessageParts.push(
              `${newUniqueDataCount} ${pluralize(
                newUniqueDataCount,
                "novo",
                "novos"
              )} MTR${pluralize(newUniqueDataCount, "", "s")} ${pluralize(
                newUniqueDataCount,
                "extraído",
                "extraídos"
              )} e ${pluralize(newUniqueDataCount, "salvo", "salvos")}.`
            );
            feedbackType = "success";
          }

          if (duplicatesInCurrentSelectionCount > 0) {
            feedbackMessageParts.push(
              `${duplicatesInCurrentSelectionCount} MTR${pluralize(
                duplicatesInCurrentSelectionCount,
                "",
                "s"
              )} ${pluralize(
                duplicatesInCurrentSelectionCount,
                "duplicado",
                "duplicados"
              )} na seleção atual (não ${pluralize(
                duplicatesInCurrentSelectionCount,
                "exibido",
                "exibidos"
              )}).`
            );
            if (feedbackType === "success") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "exists";
            }
          }

          if (existingDuplicatesInLocalStorageCount > 0) {
            feedbackMessageParts.push(
              `${existingDuplicatesInLocalStorageCount} MTR${pluralize(
                existingDuplicatesInLocalStorageCount,
                "",
                "s"
              )} já ${pluralize(
                existingDuplicatesInLocalStorageCount,
                "existente",
                "existentes"
              )} no histórico (não ${pluralize(
                existingDuplicatesInLocalStorageCount,
                "salvo",
                "salvos"
              )}).`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "exists";
            }
          }

          if (noMtrDataCount > 0) {
            feedbackMessageParts.push(
              `${noMtrDataCount} PDF${pluralize(
                noMtrDataCount,
                "",
                "s"
              )} sem ${pluralize(
                noMtrDataCount,
                "dado",
                "dados"
              )} MTR ${pluralize(noMtrDataCount, "válido", "válidos")}.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists"; // Mixed result
            } else {
              feedbackType = "no_data"; // Only this type of problem
            }
          }

          if (multiPageCount > 0) {
            feedbackMessageParts.push(
              `${multiPageCount} PDF${pluralize(
                multiPageCount,
                "",
                "s"
              )} com ${pluralize(
                multiPageCount,
                "múltipla",
                "múltiplas"
              )} página${pluralize(multiPageCount, "", "s")} ${pluralize(
                multiPageCount,
                "ignorado",
                "ignorados"
              )}.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "no_data";
            }
          }

          if (nonPdfCount > 0) {
            feedbackMessageParts.push(
              `${nonPdfCount} ${pluralize(
                nonPdfCount,
                "arquivo",
                "arquivos"
              )} não PDF ${pluralize(nonPdfCount, "ignorado", "ignorados")}.`
            );
            if (feedbackType === "success" || feedbackType === "exists") {
              feedbackType = "exists";
            } else {
              feedbackType = "no_data";
            }
          }

          if (otherErrorCount > 0) {
            feedbackMessageParts.push(
              `${otherErrorCount} ${pluralize(
                otherErrorCount,
                "arquivo",
                "arquivos"
              )} com ${pluralize(
                otherErrorCount,
                "outro",
                "outros"
              )} ${pluralize(
                otherErrorCount,
                "erro",
                "erros"
              )}. (Consulte o console para detalhes)`
            );
            if (
              feedbackType === "success" ||
              feedbackType === "exists" ||
              feedbackType === "no_data"
            ) {
              feedbackType = "error"; // Elevate to error if there are parsing errors
            } else {
              feedbackType = "error";
            }
          }

          let finalMessage = "";
          if (feedbackMessageParts.length > 0) {
            finalMessage =
              `Processamento de ${totalFilesAttemptedForProcessing} ${pluralize(
                totalFilesAttemptedForProcessing,
                "arquivo",
                "arquivos"
              )} concluído: ` + feedbackMessageParts.join(" ");
          } else {
            if (totalFilesAttemptedForProcessing > 0) {
              finalMessage = `Processamento de ${totalFilesAttemptedForProcessing} ${pluralize(
                totalFilesAttemptedForProcessing,
                "arquivo",
                "arquivos"
              )} concluído: Nenhum dado válido de MTR foi encontrado.`;
              feedbackType = "no_data";
            } else {
              finalMessage = "Nenhum arquivo foi selecionado ou solto.";
              feedbackType = "no_data";
            }
          }

          showAlertModal(finalMessage, feedbackType);

          updateHistoryButtonVisibility();
        }

        // Função para atualizar a visibilidade dos botões de ação na página inicial
        function updateActionButtonsVisibility() {
          const editSelectedBtn = document.getElementById("editSelectedBtn"); // Editar Grupo
          const deleteSelectedBtn =
            document.getElementById("deleteSelectedBtn"); // Excluir Selecionados
          const selectedCountSpan = document.getElementById("selectedCount");
          const deleteSelectedCountSpan = document.getElementById(
            "deleteSelectedCount"
          );
          const toggleEditModeBtn =
            document.getElementById("toggleEditModeBtn"); // Editar Tabela / Encerrar Edição
          const batchEditBtn = document.getElementById("batchEditBtn"); // Edição em Lote
          const dashboardLinkButton = document.getElementById(
            "dashboardLinkButton"
          ); // Botão Dashboard
          const historicalRecordsButton = document.getElementById(
            "historicalRecordsButton"
          ); // Botão Histórico
          const copyTableDataBtn = document.getElementById("copyTableDataBtn"); // Botão Copiar Dados

          // Atualiza as contagens exibidas nos botões
          if (selectedCountSpan)
            selectedCountSpan.textContent = selectedMTRs.size;
          if (deleteSelectedCountSpan)
            deleteSelectedCountSpan.textContent = selectedMTRs.size;
          if (batchEditBtn) {
            const batchEditCountSpan =
              batchEditBtn.querySelector("#batchEditCount");
            if (batchEditCountSpan)
              batchEditCountSpan.textContent = selectedMTRs.size;
          }

          const hasDataInCurrentTable = currentTableData.length > 0;
          const hasSelectedItems = selectedMTRs.size > 0;
          const hasStoredDataInLocalStorage =
            JSON.parse(localStorage.getItem("residuosData") || "[]").length > 0;

          // --- Lógica para o Botão de Alternar Modo de Edição ("Editar Tabela" / "Encerrar Edição") ---
          if (toggleEditModeBtn) {
            // Botão visível se há dados na tabela e não há itens selecionados, OU se já está no modo de edição.
            if (hasDataInCurrentTable && !hasSelectedItems) {
              toggleEditModeBtn.style.display = "inline-block";
            } else {
              toggleEditModeBtn.style.display = "none";
            }
            // Se já estiver no modo de edição, o botão deve permanecer visível para a opção "Encerrar Edição"
            if (isEditModeActive) {
              toggleEditModeBtn.style.display = "inline-block";
            }
          }

          // --- Lógica para os Botões "Editar Grupo" e "Excluir Selecionados" ---
          if (editSelectedBtn && deleteSelectedBtn) {
            // Estes botões ficam ativos (visíveis) quando há itens selecionados E NÃO está no modo de edição direta.
            if (hasSelectedItems && !isEditModeActive) {
              editSelectedBtn.classList.add("active");
              deleteSelectedBtn.classList.add("active");
            } else {
              editSelectedBtn.classList.remove("active");
              deleteSelectedBtn.classList.remove("active");
            }
          }

          // --- Lógica para o Botão "Edição em Lote" ---
          if (batchEditBtn) {
            // Este botão fica ativo (visível) apenas quando a página está no modo de edição direta da tabela E há itens selecionados.
            if (isEditModeActive && hasSelectedItems) {
              batchEditBtn.classList.add("active");
            } else {
              batchEditBtn.classList.remove("active");
            }
          }

          // --- Lógica para o Botão "Dashboard" e "Histórico" ---
          if (dashboardLinkButton) {
            if (
              hasStoredDataInLocalStorage &&
              !isEditModeActive &&
              !hasSelectedItems
            ) {
              dashboardLinkButton.style.display = "inline-block";
            } else {
              dashboardLinkButton.style.display = "none";
            }
          }

          if (historicalRecordsButton) {
            if (
              hasStoredDataInLocalStorage &&
              !isEditModeActive &&
              !hasSelectedItems
            ) {
              historicalRecordsButton.style.display = "inline-block";
            } else {
              historicalRecordsButton.style.display = "none";
            }
          }

          // --- Lógica para o Botão "Copiar Dados" (Novo) ---
          if (copyTableDataBtn) {
            // O botão "Copiar Dados" é mostrado se há dados na tabela atual
            // E a página NÃO está no modo de edição direta da tabela
            // E não há itens atualmente selecionados.
            if (
              hasDataInCurrentTable &&
              !isEditModeActive &&
              !hasSelectedItems
            ) {
              copyTableDataBtn.style.display = "inline-block";
            } else {
              copyTableDataBtn.style.display = "none";
            }
          }
        }

        // Função para atualizar a visibilidade do botão de histórico
        // (Esta função é uma wrapper para updateActionButtonsVisibility com um nome mais específico para o histórico)
        function updateHistoryButtonVisibility() {
          // A lógica principal agora reside em updateActionButtonsVisibility
          updateActionButtonsVisibility();
        }

        // Adiciona listener para a imagem do rodapé
        const footerImage = document.getElementById("footerImage");
        if (footerImage) {
          footerImage.addEventListener("click", () =>
            swapFooterImage(footerImage)
          );
        }

        // --- Funcionalidade de Drag and Drop (Atualizada para o body) ---
        const bodyElement = document.body;
        const dragDropOverlay = document.getElementById("dragDropOverlay");

        // Contador para controlar entradas e saídas do drag (para evitar flicker)
        let dragCounter = 0;

        bodyElement.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dragCounter++;
          if (dragCounter === 1) {
            // Só ativa quando entra pela primeira vez
            bodyElement.classList.add("blur-active");
            dragDropOverlay.classList.add("active");
          }
        });

        bodyElement.addEventListener("dragover", (e) => {
          e.preventDefault(); // Necessário para permitir o drop
          e.dataTransfer.dropEffect = "copy"; // Indica que os dados serão copiados
        });

        bodyElement.addEventListener("dragleave", (e) => {
          // Verifica se o mouse saiu completamente da janela ou de um elemento filho
          // O target.tagName é o elemento de onde o dragleave aconteceu.
          // relacionados target é o elemento para onde o mouse está indo.
          // Se relatedTarget for null (significa que saiu da janela) ou fora de body.
          // Isso evita que o efeito seja desativado ao passar sobre elementos internos.
          dragCounter--;
          if (dragCounter === 0) {
            bodyElement.classList.remove("blur-active");
            dragDropOverlay.classList.remove("active");
          }
        });

        bodyElement.addEventListener("drop", async (e) => {
          e.preventDefault();
          dragCounter = 0; // Reseta o contador
          bodyElement.classList.remove("blur-active");
          dragDropOverlay.classList.remove("active");

          // Passar o objeto DataTransfer completo para handleFiles
          await handleFiles(e.dataTransfer);
        });
        // --- Fim da Funcionalidade de Drag and Drop ---

        // Adiciona listener para o input de arquivo (botão "Selecionar PDFs")
        const pdfInput = document.getElementById("pdfInput");
        if (pdfInput) {
          pdfInput.addEventListener("change", async (e) => {
            await handleFiles(e.target.files);
            e.target.value = ""; // Limpa o input para permitir selecionar os mesmos arquivos novamente
          });
        }

        // --- Adiciona listeners para os novos botões de ação ---
        const toggleEditModeBtn = document.getElementById("toggleEditModeBtn");
        if (toggleEditModeBtn) {
          toggleEditModeBtn.addEventListener("click", toggleEditMode);
        }

        const copyTableDataBtn = document.getElementById("copyTableDataBtn");
        if (copyTableDataBtn) {
          copyTableDataBtn.addEventListener("click", copyTableDataToClipboard);
        }
        // Chamada inicial para garantir que o botão esteja no estado correto ao carregar a página
        updateHistoryButtonVisibility();

        // --- Gerenciamento de Ações em Massa de Grupo ---
        const editSelectedBtn = document.getElementById("editSelectedBtn"); // Botão "Editar Grupo"
        const deleteSelectedBtn = document.getElementById("deleteSelectedBtn");
        const bulkEditModal = document.getElementById("bulkEditModal"); // Modal de edição de grupo
        const bulkEditGroupInput =
          document.getElementById("bulkEditGroupInput");
        const bulkEditModalSaveBtn = document.getElementById(
          "bulkEditModalSaveBtn"
        );
        const bulkEditModalCancelBtn = document.getElementById(
          "bulkEditModalCancelBtn"
        );
        const bulkEditSelectedCountSpan = document.getElementById(
          "bulkEditSelectedCount"
        );

        if (editSelectedBtn) {
          editSelectedBtn.addEventListener("click", () => {
            if (selectedMTRs.size === 0) {
              showAlertModal(
                "Nenhum MTR selecionado para editar o grupo.",
                "no_data"
              );
              return;
            }
            bulkEditSelectedCountSpan.textContent = selectedMTRs.size;
            bulkEditGroupInput.value = ""; // Clear input
            bulkEditModal.style.display = "flex"; // Show modal
            bulkEditGroupInput.focus();
          });
        }

        // Adiciona listeners para Enter e Esc no input do modal de edição de grupo
        if (bulkEditGroupInput) {
          bulkEditGroupInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              bulkEditModalSaveBtn.click();
            } else if (e.key === "Escape") {
              e.preventDefault();
              bulkEditModalCancelBtn.click();
            }
          });
        }

        if (bulkEditModalSaveBtn) {
          bulkEditModalSaveBtn.addEventListener("click", () => {
            const newGroup = bulkEditGroupInput.value.trim();
            let changesMade = 0;
            let storedData = JSON.parse(
              localStorage.getItem("residuosData") || "[]"
            );

            selectedMTRs.forEach((uniqueId) => {
              const [mtrId, dateId] = uniqueId.split("_");
              // Find and update in currentTableData
              const currentItem = currentTableData.find(
                (item) =>
                  item.mtrFormatted === mtrId && item.dataEmissao === dateId
              );
              if (currentItem && currentItem.grupo !== newGroup) {
                currentItem.grupo = newGroup;
                changesMade++;
              }

              // Find and update in localStorage data
              const storedItem = storedData.find(
                (item) =>
                  item.mtrFormatted === mtrId && item.dataEmissao === dateId
              );
              if (storedItem && storedItem.grupo !== newGroup) {
                storedItem.grupo = newGroup;
              }
            });

            localStorage.setItem("residuosData", JSON.stringify(storedData));
            bulkEditModal.style.display = "none";
            selectedMTRs.clear(); // Limpa seleção após a ação
            renderTable(currentTableData); // Re-render to reflect changes
            showAlertModal(
              `${changesMade} MTR(s) tiveram o grupo atualizado.`,
              "success"
            );
            updateActionButtonsVisibility();
            const selectAllCheckbox =
              document.getElementById("selectAllCheckbox");
            if (selectAllCheckbox) selectAllCheckbox.checked = false; // Deselect "select all"
          });
        }

        if (bulkEditModalCancelBtn) {
          bulkEditModalCancelBtn.addEventListener("click", () => {
            bulkEditModal.style.display = "none";
          });
        }

        // --- Excluir Selecionados ---
        if (deleteSelectedBtn) {
          deleteSelectedBtn.addEventListener("click", () => {
            if (selectedMTRs.size === 0) {
              showAlertModal("Nenhum MTR selecionado para excluir.", "no_data");
              return;
            }
            showFolderConfirmModal(
              `Tem certeza que deseja excluir ${selectedMTRs.size} MTR(s) selecionado(s)? Esta ação não pode ser desfeita.`
            ).then((confirmed) => {
              if (confirmed) {
                const originalCurrentTableDataLength = currentTableData.length;
                currentTableData = currentTableData.filter((item) => {
                  const uniqueId = `${item.mtrFormatted}_${item.dataEmissao}`;
                  return !selectedMTRs.has(uniqueId);
                });

                let storedData = JSON.parse(
                  localStorage.getItem("residuosData") || "[]"
                );
                storedData = storedData.filter((item) => {
                  const uniqueId = `${item.mtrFormatted}_${item.dataEmissao}`;
                  return !selectedMTRs.has(uniqueId);
                });
                localStorage.setItem(
                  "residuosData",
                  JSON.stringify(storedData)
                );

                const deletedCount =
                  originalCurrentTableDataLength - currentTableData.length;
                selectedMTRs.clear();
                renderTable(currentTableData); // Re-render with remaining items
                showAlertModal(
                  `${deletedCount} MTR(s) excluído(s) com sucesso.`,
                  "success"
                );
                updateHistoryButtonVisibility(); // Update general buttons
                updateActionButtonsVisibility();
                const selectAllCheckbox =
                  document.getElementById("selectAllCheckbox");
                if (selectAllCheckbox) selectAllCheckbox.checked = false;
              }
            });
          });
        }

        // --- Gerenciamento de Edição em Lote (genérico) ---
        const batchEditBtn = document.getElementById("batchEditBtn");
        const batchEditBatchModal = document.getElementById(
          "batchEditBatchModal"
        );
        const batchEditFieldSelect = document.getElementById(
          "batchEditFieldSelect"
        );
        const batchEditValueInput = document.getElementById(
          "batchEditValueInput"
        );
        const batchEditModalSaveBtn = document.getElementById(
          "batchEditModalSaveBtn"
        );
        const batchEditModalCancelBtn = document.getElementById(
          "batchEditModalCancelBtn"
        );
        const batchEditCountModalSpan = document.getElementById(
          "batchEditCountModal"
        );

        if (batchEditBtn) {
          batchEditBtn.addEventListener("click", () => {
            if (selectedMTRs.size === 0) {
              showAlertModal(
                "Nenhum MTR selecionado para edição em lote.",
                "no_data"
              );
              return;
            }
            batchEditCountModalSpan.textContent = selectedMTRs.size;
            batchEditFieldSelect.value = ""; // Reseta seleção do campo
            batchEditValueInput.value = ""; // Limpa o input de valor
            batchEditValueInput.style.display = "none"; // Esconde o input de valor inicialmente
            batchEditBatchModal.style.display = "flex"; // Mostra o modal
          });
        }

        if (batchEditFieldSelect) {
          batchEditFieldSelect.addEventListener("change", () => {
            if (batchEditFieldSelect.value) {
              batchEditValueInput.style.display = "block";
              batchEditValueInput.focus();
            } else {
              batchEditValueInput.style.display = "none";
              batchEditValueInput.value = "";
            }
          });
        }

        // Adiciona listeners para Enter e Esc no input do modal de edição em lote
        if (batchEditValueInput) {
          batchEditValueInput.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              batchEditModalSaveBtn.click();
            } else if (e.key === "Escape") {
              e.preventDefault();
              batchEditModalCancelBtn.click();
            }
          });
        }

        if (batchEditModalSaveBtn) {
          batchEditModalSaveBtn.addEventListener("click", () => {
            const fieldToUpdate = batchEditFieldSelect.value;
            const newValue = batchEditValueInput.value.trim();

            if (!fieldToUpdate) {
              showAlertModal(
                "Por favor, selecione um campo para editar.",
                "error"
              );
              return;
            }

            // Esconde o modal de edição em lote antes de mostrar o de confirmação
            batchEditBatchModal.style.display = "none";

            showFolderConfirmModal(
              `Tem certeza que deseja alterar o campo '${fieldToUpdate}' para '${newValue}' em ${selectedMTRs.size} MTR(s) selecionado(s)? Esta ação não pode ser desfeita.`
            ).then((confirmed) => {
              if (confirmed) {
                let changesMade = 0;
                let storedData = JSON.parse(
                  localStorage.getItem("residuosData") || "[]"
                );

                selectedMTRs.forEach((uniqueId) => {
                  const [mtrId, dateId] = uniqueId.split("_");

                  // Update in currentTableData
                  const currentItem = currentTableData.find(
                    (item) =>
                      item.mtrFormatted === mtrId && item.dataEmissao === dateId
                  );
                  if (currentItem && currentItem[fieldToUpdate] !== newValue) {
                    // Specific validation for numeric fields during batch edit
                    if (
                      fieldToUpdate === "litros" ||
                      fieldToUpdate === "toneladas"
                    ) {
                      const parsedValue = parseFloat(
                        newValue.replace(",", ".")
                      );
                      if (isNaN(parsedValue)) {
                        console.error(
                          `Valor inválido para ${fieldToUpdate} para MTR ${mtrId}. Pulando atualização.`
                        );
                        return; // Skip this item if invalid
                      }
                    }
                    currentItem[fieldToUpdate] = newValue;
                    changesMade++;
                  }

                  // Update in localStorage data
                  const storedItem = storedData.find(
                    (item) =>
                      item.mtrFormatted === mtrId && item.dataEmissao === dateId
                  );
                  if (storedItem && storedItem[fieldToUpdate] !== newValue) {
                    // Specific validation for numeric fields in localStorage data
                    if (
                      fieldToUpdate === "litros" ||
                      fieldToUpdate === "toneladas"
                    ) {
                      const parsedValue = parseFloat(
                        newValue.replace(",", ".")
                      );
                      if (isNaN(parsedValue)) {
                        return; // Skip update in localStorage if invalid
                      }
                    }
                    storedItem[fieldToUpdate] = newValue;
                  }
                });

                localStorage.setItem(
                  "residuosData",
                  JSON.stringify(storedData)
                );
                selectedMTRs.clear(); // Limpa seleção após a ação
                renderTable(currentTableData); // Re-render to reflect changes
                showAlertModal(
                  `${changesMade} MTR(s) tiveram o campo '${fieldToUpdate}' atualizado.`,
                  "success"
                );
                updateActionButtonsVisibility();
                const selectAllCheckbox =
                  document.getElementById("selectAllCheckbox");
                if (selectAllCheckbox) selectAllCheckbox.checked = false; // Desseleciona "selecionar todos"
              } else {
                // Se o usuário cancelar a confirmação, mostra o modal de edição em lote novamente
                batchEditBatchModal.style.display = "flex";
              }
            });
          });
        }

        if (batchEditModalCancelBtn) {
          batchEditModalCancelBtn.addEventListener("click", () => {
            batchEditBatchModal.style.display = "none";
          });
        }
      }); // Fechamento do DOMContentLoaded
    </script>
  </body>
</html>
